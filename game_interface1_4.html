<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XEMK</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .game-container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .player-section { border: 2px solid #333; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .cards-grid { display: flex; flex-wrap: wrap; gap: 15px; margin: 10px 0; }
        .card { 
            width: 180px; 
            display: flex; flex-direction: column;
            border: 2px solid #007bff; border-radius: 8px;
            cursor: grab; background: white; transition: all 0.2s;
            user-select: none; overflow: hidden;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .card.selected { border-color: #28a745; box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3); }
        .card.used { 
            opacity: 0.5; 
            cursor: not-allowed;
            filter: grayscale(80%);
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
        }
        .card.dragging {
            opacity: 0.7;
            transform: scale(1.05);
        }
        
        /* å¡ç‰Œå†…éƒ¨æ ·å¼ */
        .card-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        .card.used .card-header {
            background: linear-gradient(135deg, #6c757d, #495057);
        }
        
        .card-body {
            padding: 10px;
            flex-grow: 1;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        
        .card-properties {
            margin-top: 8px;
            font-size: 14px;
        }
        
        .property {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 4px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .property.race {
            background: #d4edda;
            color: #155724;
        }
        
        .property.type {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .card-cost {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .cost-item {
            display: inline-block;
            margin-right: 5px;
            color: #6c757d;
        }
        
        .controls { margin: 15px 0; text-align: center; }
        button { 
            padding: 12px 24px; margin: 5px; cursor: pointer; 
            background: #28a745; color: white; border: none; border-radius: 5px;
            font-size: 16px; transition: background 0.2s;
        }
        button:hover { background: #218838; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        #gameLog { 
            height: 200px; overflow-y: auto; border: 1px solid #ccc; 
            padding: 10px; margin: 10px 0; background-color: #f8f9fa;
            border-radius: 5px; font-family: monospace;
        }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .config-section { background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px; margin: 10px 0; }
        
        /* æ–°æ·»åŠ çš„ï¼šç‰¹æ®Šæ“ä½œæŒ‰é’®å®¹å™¨æ ·å¼ */
        .special-actions-container {
            margin-top: 15px;
            display: none; /* é»˜è®¤éšè—ï¼Œæ¥æ”¶åˆ°æŒ‡ä»¤åæ˜¾ç¤º */
        }
        
        .special-actions-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .special-actions-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .special-action-box {
            width: 180px;
            height: 240px;
            border: 3px dashed #007bff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .special-action-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
            border-color: #0056b3;
            background-color: #f0f8ff;
        }
        
        .special-action-box.option1 {
            border-color: #ff6b6b;
        }
        
        .special-action-box.option2 {
            border-color: #4ecdc4;
        }
        
        .special-action-box.option1:hover {
            background-color: #fff0f0;
        }
        
        .special-action-box.option2:hover {
            background-color: #f0fafa;
        }
        
        .special-action-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .special-action-text {
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            padding: 0 10px;
        }
        
        .special-action-desc {
            font-size: 12px;
            color: #666;
            text-align: center;
            padding: 0 10px;
            margin-top: 8px;
        }
        
        /* å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œæ ·å¼ */
        .current-round-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }
        
        .current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slot {
            width: 80%;
            min-height: 180px;
            border: 3px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: white;
            transition: all 0.2s;
            position: relative;
            padding: 10px;
            overflow-y: auto;
        }
        
        .slot.highlight {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .slot-card {
            width: 170px;
            margin-bottom: 10px;
        }
        
        .slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        .clear-slot-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: #ffc107;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            display: none;
            z-index: 5;
        }
        
        .clear-slot-btn:hover {
            background: #e0a800 !important;
        }
        
        .clear-single-card-btn:hover {
            background: #c82333 !important;
        }
        
        .slot:hover .clear-slot-btn {
            display: block;
        }
        
        /* å¯¹æ–¹å½“å‰å›åˆæ ·å¼ */
        .opponent-current-round-section {
            margin-top: 30px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            border: 2px solid #ced4da;
        }
        
        .opponent-current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .opponent-slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .opponent-slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .opponent-slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .opponent-slot {
            width: 80%;
            min-height: 180px;
            border: 3px solid #6c757d;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: #f8f9fa;
            padding: 10px;
            overflow-y: auto;
        }
        
        .opponent-slot-card {
            width: 170px;
            margin-bottom: 10px;
            opacity: 0.9;
        }
        
        .opponent-slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        /* å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— */
        .card-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .card-detail-content {
            background: white;
            border-radius: 10px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .card-detail-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .card-detail-body {
            padding: 20px;
        }
        
        .detail-row {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .detail-label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }
        
        .detail-value {
            font-size: 16px;
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="text-align: center; color: #333;">ğŸƒ XEMK</h1>
        
        <div class="config-section">
            <h3>âš™ï¸ è¿æ¥è®¾ç½®</h3>
            <label for="serverIP">æ¸¸æˆæœåŠ¡å™¨IPåœ°å€:</label>
            <input type="text" id="serverIP" value="10.2.3.31" style="padding: 5px; margin: 0 10px;">
            <button onclick="updateServerIP()">æ›´æ–°è¿æ¥</button>
            <p><small>æç¤º: åœ¨ROS 2ä¸»æœºä¸Šè¿è¡Œ <code>hostname -I</code> æŸ¥çœ‹IPåœ°å€</small></p>
            
            <!-- æ–°å¢çš„ç‰¹æ®Šæ“ä½œæŒ‰é’®åŒºåŸŸ -->
            <div class="special-actions-container" id="specialActionsContainer">
                <div class="special-actions-title">âš¡ ç‰¹æ®Šæ“ä½œ</div>
                <div class="special-actions-buttons">
                    <div class="special-action-box option1" onclick="sendSpecialAction('squirrels')">
                        <div class="special-action-icon">ğŸ”µ</div>
                        <div class="special-action-text">æ¾é¼ </div>
                        <div class="special-action-desc">é€‰æ‹©æ¾é¼ ç‰Œ</div>
                    </div>
                    <div class="special-action-box option2" onclick="sendSpecialAction('creations')">
                        <div class="special-action-icon">ğŸ”´</div>
                        <div class="special-action-text">é€ ç‰©</div>
                        <div class="special-action-desc">é€‰æ‹©é€ ç‰©ç‰Œ</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="connectionStatus" class="status info">å‡†å¤‡è¿æ¥...</div>
        
        <div class="player-section">
            <h2>ğŸƒ Your Cards</h2>
            <div id="cardsGrid" class="cards-grid">No cards yet. Join the game first.</div>
            
            <!-- å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œï¼ˆå¯æ”¾ç½®åŒºåŸŸï¼‰ -->
            <div class="current-round-section">
                <h3>å½“å‰å›åˆè¦ä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="slot-container">
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 1</div>
                        <div class="slot" data-slot-index="0" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(0)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 2</div>
                        <div class="slot" data-slot-index="1" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(1)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 3</div>
                        <div class="slot" data-slot-index="2" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(2)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 4</div>
                        <div class="slot" data-slot-index="3" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(3)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ -->
            <div class="opponent-current-round-section">
                <h3>å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="opponent-slot-container">
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 1</div>
                        <div class="opponent-slot" data-opponent-slot-index="0">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 2</div>
                        <div class="opponent-slot" data-opponent-slot-index="1">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 3</div>
                        <div class="opponent-slot" data-opponent-slot-index="2">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 4</div>
                        <div class="opponent-slot" data-opponent-slot-index="3">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="joinButton" onclick="joinGame()">åŠ å…¥æ¸¸æˆ</button>
                <button id="endButton" onclick="ReGame()">é‡æ–°å¼€å§‹</button>
                <button id="playButton" onclick="playCurrentRoundCards()" disabled>ç»“æŸå·±æ–¹å›åˆ</button>
                <!-- <button id="skipButton" onclick="skip()" disabled>è·³è¿‡</button> -->
            </div>
        </div>
        
        <div class="player-section">
            <h2>ğŸ“ æ¸¸æˆæ—¥å¿—</h2>
            <div id="gameLog">æ¸¸æˆæ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        </div>
    </div>

    <!-- å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— -->
    <div class="card-detail-modal" id="cardDetailModal">
        <div class="card-detail-content">
            <div class="card-detail-header">
                <span id="detailCardName">å¡ç‰Œåç§°</span>
                <button class="close-modal" onclick="closeCardDetail()">Ã—</button>
            </div>
            <div class="card-detail-body">
                <div class="detail-row">
                    <div class="detail-label">ç”Ÿå‘½å€¼ (HP)</div>
                    <div class="detail-value" id="detailCardHP">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">æ”»å‡»åŠ› (ATK)</div>
                    <div class="detail-value" id="detailCardATK">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">å±æ€§</div>
                    <div class="detail-value" id="detailCardProperty">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">ç§æ—</div>
                    <div class="detail-value" id="detailCardRace">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">è´¹ç”¨</div>
                    <div class="detail-value" id="detailCardCost">æ— </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GameClient {
            constructor() {
                this.ws = null;
                this.playerId = null;
                this.cards = []; // å­˜å‚¨å¡ç‰Œå¯¹è±¡æ•°ç»„
                this.connected = false;
                this.serverIP = '10.2.3.31';
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.round = 0;
                this.currentRound = 0;
                this.skip = '';
                
                // å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.currentRoundSlots = [[], [], [], []];
                // å¯¹æ–¹å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.opponentCurrentRoundSlots = [[], [], [], []];
                // æœ€è¿‘ç‚¹å‡»çš„å¡ç‰Œï¼ˆç”¨äºç‚¹å‡»æ”¾ç½®ï¼‰
                this.lastClickedCard = null;
                // å¡ç‰Œä½¿ç”¨çŠ¶æ€æ˜ å°„
                this.cardUsageMap = new Map(); // æ ¼å¼: uniqueId -> {card: object, used: boolean, slotIndex: number}
                // ç”¨äºåŒæ­¥å¯¹æ–¹æ˜¾ç¤ºçš„ä¸´æ—¶æ•°æ®
                this.pendingOpponentCards = [[], [], [], []];
                
                // ä»URLè·å–ç©å®¶ID
                const urlParams = new URLSearchParams(window.location.search);
                this.playerId = urlParams.get('player') || 'player1';
                
                // è®¾ç½®IPè¾“å…¥æ¡†çš„é»˜è®¤å€¼
                document.getElementById('serverIP').value = this.getDefaultIP();
                
                this.connect();
                this.initDragAndDrop();
            }
            
            getDefaultIP() {
                return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                    ? 'localhost' 
                    : '10.2.3.31';
            }
            
            initDragAndDrop() {
                // å¡ç‰Œæ‹–åŠ¨äº‹ä»¶
                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('card') && !e.target.classList.contains('used')) {
                        const cardIndex = parseInt(e.target.dataset.index);
                        const uniqueId = e.target.dataset.uniqueId;
                        const usage = this.cardUsageMap.get(uniqueId);
                        const card = usage ? usage.card : this.cards[cardIndex];
                        
                        e.dataTransfer.setData('application/json', JSON.stringify({
                            card: card,
                            index: cardIndex,
                            uniqueId: uniqueId
                        }));
                        e.target.classList.add('dragging');
                    }
                });
                
                document.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('card')) {
                        e.target.classList.remove('dragging');
                    }
                });
            }
            
            connect() {
                if (this.ws) {
                    this.ws.close();
                }
                
                this.serverIP = document.getElementById('serverIP').value || this.getDefaultIP();
                const wsUrl = `ws://${this.serverIP}:8002`;
                
                try {
                    this.updateStatus(`ğŸ”— æ­£åœ¨è¿æ¥åˆ° ${this.serverIP}:8002`, 'info');
                    console.log('Connecting to:', wsUrl);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to game server');
                        this.isConnected = true;
                        this.connected = true;
                        this.reconnectAttempts = 0;
                        this.updateStatus('âœ… å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨', 'success');
                        this.addToLog('å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨ ' + this.serverIP);
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event);
                        this.isConnected = false;
                        this.connected = false;
                        
                        if (!event.wasClean) {
                            this.handleReconnect();
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('âŒ è¿æ¥é”™è¯¯', 'error');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            console.log('Raw message received:', event.data);
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            console.error('Error parsing message:', e);
                            this.addToLog('è§£ææœåŠ¡å™¨æ¶ˆæ¯æ—¶å‡ºé”™: ' + e.message);
                        }
                    };
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateStatus('âŒ åˆ›å»ºè¿æ¥å¤±è´¥', 'error');
                    this.handleReconnect();
                }
            }
            
            handleMessage(data) {
                console.log('Parsed message:', data);
                
                switch(data.type) {
                    case 'numbers_assigned':
                        // æœåŠ¡å™¨è¿”å›çš„æ˜¯å¡ç‰Œæ•°ç»„
                        this.cards = data.cards || [];
                        // this.cards_ip = data.cards_ip || [];
                        // é‡ç½®å¡ç‰Œä½¿ç”¨çŠ¶æ€
                        this.cardUsageMap.clear();
                        this.renderCards();
                        this.updateCurrentRoundDisplay();
                        this.updateOpponentCurrentRoundDisplay();
                        this.updateStatus('âœ… å¡ç‰Œåˆ†é…å®Œæˆ! æ¸¸æˆå‡†å¤‡å°±ç»ª', 'success');
                        
                        // æ˜¾ç¤ºå¡ç‰Œåç§°
                        const cardNames = this.cards.map(card => card.name).join(', ');
                        this.addToLog(`ä½ è·å¾—äº† ${this.cards.length} å¼ å¡ç‰Œ: ${cardNames}`);
                        
                        if (this.round % 2 === 0) {
                            this.currentRound = this.round / 2;
                            this.addToLog(`å›åˆ ${this.currentRound}`);
                        }
                        this.round += 1;
                        break;
                        
                    case 'game_start':
                        this.addToLog('ğŸ® æ¸¸æˆå¼€å§‹! åŒæ–¹ç©å®¶å·²å°±ä½');
                        this.addToLog(`ä¸Šæ¬¡å‡ºç‰Œ: ${data.last_player}`);
                        this.cardUsageMap.clear();
                        this.currentRoundSlots = [[], [], [], []];
                        this.opponentCurrentRoundSlots = [[], [], [], []];
                        this.pendingOpponentCards = [[], [], [], []];
                        this.renderCards();
                        this.updateCurrentRoundDisplay();
                        this.updateOpponentCurrentRoundDisplay();
                        break;
                        
                    case 'move_accepted'://é€šçŸ¥è‡ªå·±åœºä¸Šå¡ç‰Œçš„å˜åŠ¨
                        this.addToLog(`âœ… ${data.message}`);
                        
                        // è°ƒè¯•ä¿¡æ¯
                        console.log('move_accepted data:', data);
                        this.addToLog(`æ”¶åˆ°æœåŠ¡å™¨ç¡®è®¤ï¼Œå¡ç‰Œæ•°é‡: ${data.cards_played ? data.cards_played.length : 0}`);
                        
                        if (data.cards_played && Array.isArray(data.cards_played)) {
                            // è°ƒè¯•ï¼šæŸ¥çœ‹cards_playedçš„å®é™…å†…å®¹
                            for(let i = 0; i < 4; i++) {
                                const item = data.cards_played[i];
                                if (item!== null) {
                                    this.addToLog(`cards_played[${i}]: ${item.name} (id: ${item.id || item.card_id})`);
                                } else {
                                    this.addToLog(`cards_played[${i}]: null`);
                                }
                            }
                            
                            // æ¸…ç©ºå½“å‰å›åˆæ‰€æœ‰æ ä½
                            this.currentRoundSlots = [[], [], [], []];
                            
                            // æ ¹æ®æœåŠ¡å™¨æ•°æ®ç»“æ„è§£æï¼šæ‰å¹³æ•°ç»„ï¼ŒæŒ‰æ ä½é¡ºåºæ’åˆ—
                            // å‡è®¾ï¼šæ¯ä¸ªæ ä½å¯èƒ½æœ‰å¤šä¸ªå¡ç‰Œï¼Œä½†æœåŠ¡å™¨åªè¿”å›å®é™…å­˜åœ¨çš„å¡ç‰Œ
                            // æˆ‘ä»¬éœ€è¦é‡æ–°ç»„ç»‡è¿™äº›å¡ç‰Œåˆ°4ä¸ªæ ä½
                            
                            // æ–¹æ³•1ï¼šå‡è®¾æ¯4ä¸ªå…ƒç´ å¯¹åº”ä¸€ä¸ªæ ä½
                            const cardsPerSlot = Math.ceil(data.cards_played.length / 4);
                            for (let slotIndex = 0; slotIndex < 4; slotIndex++) {
                                const startIndex = slotIndex * cardsPerSlot;
                                const endIndex = startIndex + cardsPerSlot;
                                
                                for (let i = startIndex; i < endIndex && i < data.cards_played.length; i++) {
                                    const cardData = data.cards_played[i];
                                    if (cardData !== null) {
                                        this.currentRoundSlots[slotIndex].push(cardData);
                                    }
                                }
                            }
                           
                            // é‡ç½®å¡ç‰Œä½¿ç”¨çŠ¶æ€
                            for (const usage of this.cardUsageMap.values()) {
                                usage.used = false;
                                usage.slotIndex = -1;
                            }
                            
                            this.renderCards();
                            this.updateCurrentRoundDisplay();
                            this.addToLog(`æœåŠ¡å™¨ç¡®è®¤ï¼Œæ ä½å·²æ›´æ–°`);
                        }
                        break;
                                            
                    case 'opponent_move':
                        // å¤„ç†å¯¹æ–¹æ‰“å‡ºçš„å¡ç‰Œ
                        if (data.cards_played && data.cards_played.length > 0) {
                            // è·å–å¡ç‰Œåç§°åˆ—è¡¨ï¼ˆè·³è¿‡nullå€¼ï¼‰
                            const validCards = data.cards_played.filter(card => card !== null);
                            const cardNames = validCards.map(card => card.name).join(', ');
                            
                            // æ›´æ–°æ—¥å¿—
                            this.addToLog(`å¯¹æ–¹æ‰“å‡ºå¡ç‰Œ: ${cardNames}`);
                            
                            // æ¸…ç©ºå¯¹æ–¹æ ä½
                            this.opponentCurrentRoundSlots = [[], [], [], []];
                            
                            // è§£ææ‰å¹³åŒ–çš„å¡ç‰Œæ•°ç»„åˆ°4ä¸ªæ ä½
                            // ç”±äºæœåŠ¡å™¨æ²¡æœ‰æ˜ç¡®çš„åˆ†éš”ç¬¦ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®åŸå§‹å¸ƒå±€çŒœæµ‹
                            // æˆ–è€…å‡è®¾æ¯ä¸ªæ ä½æœ€å¤šXå¼ å¡ç‰Œ
                            
                            // æ–¹æ³•1ï¼šå¦‚æœçŸ¥é“æ¯ä¸ªæ ä½çš„å¡ç‰Œæ•°é‡
                            let currentSlotIndex = 0;
                            let cardsInCurrentSlot = 0;
                            
                            data.cards_played.forEach((cardData, index) => {
                                if (cardData === null) {
                                    // nullè¡¨ç¤ºå¡ç‰Œæ— æ•ˆï¼Œä½†æˆ‘ä»¬ä¸çŸ¥é“æ˜¯å¦æ˜¯æ ä½åˆ†éš”ç¬¦
                                    // å¯èƒ½åªæ˜¯è¡¨ç¤ºæŸä¸ªæ ä½æ²¡æœ‰å¡ç‰Œ
                                    // è¿™é‡Œæˆ‘ä»¬ä¿å®ˆå¤„ç†ï¼šä¸åˆ‡æ¢æ ä½
                                    return;
                                }
                                
                                // æ·»åŠ åˆ°å½“å‰æ ä½
                                if (currentSlotIndex < 4) {
                                    this.opponentCurrentRoundSlots[currentSlotIndex].push(cardData);
                                    cardsInCurrentSlot++;
                                    
                                    // å‡è®¾æ¯ä¸ªæ ä½æœ€å¤šæ”¾ç½®2å¼ å¡ç‰Œï¼ˆæ ¹æ®æ¸¸æˆè§„åˆ™è°ƒæ•´ï¼‰
                                    if (cardsInCurrentSlot >= 2) {
                                        currentSlotIndex++;
                                        cardsInCurrentSlot = 0;
                                    }
                                }
                            });
                            
                            // æ–¹æ³•2ï¼šå¦‚æœæœ‰æ˜ç¡®çš„æ ä½åˆ†é…ä¿¡æ¯
                            if (data.slots && Array.isArray(data.slots)) {
                                this.addToLog(`ä½¿ç”¨æ˜ç¡®çš„æ ä½åˆ†é…ä¿¡æ¯`);
                                for (let i = 0; i < Math.min(data.slots.length, 4); i++) {
                                    this.opponentCurrentRoundSlots[i] = data.slots[i] || [];
                                }
                            }
                            
                            // æ›´æ–°UIæ˜¾ç¤º
                            this.updateOpponentCurrentRoundDisplay();
                        }
                        break;
                        
                    case 'opponent_disconnected':
                        this.addToLog(`âš ï¸ ${data.message}`);
                        break;
                        
                    case 'opponent_reconnected':
                        this.addToLog(`ğŸ”— ${data.message}`);
                        break;
                        
                    case 'waiting_for_opponent':
                        this.addToLog(`â³ ${data.message}`);
                        break;
                        
                    case 'special_action_request': // æ–°å¢ï¼šæ¥æ”¶åˆ°ç‰¹æ®Šæ“ä½œæŒ‡ä»¤
                        this.showSpecialActions(data.instruction || 'è¯·é€‰æ‹©æ“ä½œ');
                        break;
                }
            }
            playCurrentRoundCards() {
                if (!this.connected ) {
                    this.addToLog('âŒè¿æ¥å¤±è´¥');
                    return;
                }
                
                // æ”¶é›†æ‰€æœ‰æ ä½çš„å¡ç‰Œ
                const allCards = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    const slotCards = this.currentRoundSlots[i].map(card => {
                        return {
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            cost: card.cost,
                            id: card.card_id
                        };
                    });
                    allCards.push(...slotCards);
                }
                
                if (allCards.length === 0) {
                    this.addToLog('å·²ç»“æŸï¼Œæ²¡æœ‰å‡ºç‰Œ');
                    document.getElementById('playButton').disabled = true;
                    return;
                }
                
                // è®°å½•å“ªäº›å¡ç‰Œè¢«æ‰“å‡ºäº†ï¼ˆæ°¸ä¹…ç§»é™¤ï¼‰
                const playedUniqueIds = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    this.currentRoundSlots[i].forEach(card => {
                        playedUniqueIds.push(card.uniqueId);
                    });
                }
                
                const playMsg = {
                    type: 'player_action',
                    player_id: this.playerId,
                    cards: allCards.map(card => card.name),
                    slots: this.currentRoundSlots.map(slot => 
                        slot.map(card => ({
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            id: card.card_id
                        }))
                    ),
                    card_details: allCards
                };
                
                console.log('Sending play message:', playMsg);
                this.sendMessage(playMsg);
                this.addToLog(`æ‰“å‡ºå¡ç‰Œ: ${allCards.map(c => c.name).join(', ')}`);
                
                // ä»å¡ç‰Œåˆ—è¡¨ä¸­æ°¸ä¹…ç§»é™¤æ‰“å‡ºçš„å¡ç‰Œ
                this.cards = this.cards.filter((card, index) => {
                    const uniqueId = `${card.name}_${index}`;
                    return !playedUniqueIds.includes(uniqueId);
                });
                
                // æ¸…é™¤å¡ç‰Œä½¿ç”¨çŠ¶æ€
                playedUniqueIds.forEach(uniqueId => {
                    this.cardUsageMap.delete(uniqueId);
                });
                
                // é‡ç½®å½“å‰å›åˆæ ä½
                this.currentRoundSlots = [[], [], [], []];
                this.lastClickedCard = null;
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }

            // æ–°å¢ï¼šæ˜¾ç¤ºç‰¹æ®Šæ“ä½œæŒ‰é’®
            showSpecialActions(instruction) {
                const container = document.getElementById('specialActionsContainer');
                if (container) {
                    // æ›´æ–°æ ‡é¢˜
                    const titleElement = container.querySelector('.special-actions-title');
                    if (titleElement) {
                        titleElement.textContent = `âš¡ ${instruction}`;
                    }
                    
                    // æ˜¾ç¤ºå®¹å™¨
                    container.style.display = 'block';
                    this.addToLog(`æ”¶åˆ°ç‰¹æ®Šæ“ä½œæŒ‡ä»¤: ${instruction}`);
                }
            }
            
            // æ–°å¢ï¼šéšè—ç‰¹æ®Šæ“ä½œæŒ‰é’®
            hideSpecialActions() {
                const container = document.getElementById('specialActionsContainer');
                if (container) {
                    container.style.display = 'none';
                }
            }
            
            // æ–°å¢ï¼šå‘é€ç‰¹æ®Šæ“ä½œæ¶ˆæ¯
            sendSpecialAction(actionType) {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const actionMsg = {
                        type: 'special_action',
                        player_id: this.playerId,
                        action_type: actionType
                    };
                    
                    this.sendMessage(actionMsg);
                    this.addToLog(`å‘é€ç‰¹æ®Šæ“ä½œ: ${actionType}`);
                    
                    // å‘é€åéšè—æŒ‰é’®åŒºåŸŸ
                    this.hideSpecialActions();
                } else {
                    this.addToLog('æ— æ³•å‘é€ç‰¹æ®Šæ“ä½œ: WebSocket æœªè¿æ¥');
                }
            }
            
            // ä¿®æ”¹åçš„ï¼šæ›´æ–°å¯¹æ–¹å¡ç‰Œä½ç½®
            updateOpponentCard(slotIndex, cardData, action) {
                if (slotIndex < 0 || slotIndex > 3) return;
                
                if (action === 'add') {
                    // æ·»åŠ å¡ç‰Œåˆ°å¯¹æ–¹å¯¹åº”æ ä½
                    this.opponentCurrentRoundSlots[slotIndex].push(cardData);
                } else if (action === 'remove') {
                    // ä»å¯¹æ–¹å¯¹åº”æ ä½ç§»é™¤å¡ç‰Œ
                    const cardIndex = this.opponentCurrentRoundSlots[slotIndex].findIndex(
                        card => card.name === cardData.name && 
                        card.HP === cardData.HP && 
                        card.ATK === cardData.ATK
                    );
                    if (cardIndex !== -1) {
                        this.opponentCurrentRoundSlots[slotIndex].splice(cardIndex, 1);
                    }
                } else if (action === 'clear') {
                    // æ¸…ç©ºå¯¹æ–¹æ•´ä¸ªæ ä½
                    this.opponentCurrentRoundSlots[slotIndex] = [];
                }
                
                this.updateOpponentCurrentRoundDisplay();
            }
            
            sendCardPlacementUpdate(slotIndex, cardData, action) {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const updateMsg = {
                        type: 'card_placement_update',
                        player_id: this.playerId,
                        slot_index: slotIndex,
                        card: cardData,
                        action: action // 'add', 'remove', 'clear'
                    };
                    
                    this.sendMessage(updateMsg);
                }
            }
            
            joinGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'player_join',
                        player_id: this.playerId
                    };
                    console.log('Sending join message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`ä»¥ ${this.playerId} èº«ä»½åŠ å…¥æ¸¸æˆ...`);
                    document.getElementById('joinButton').disabled = true;
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•åŠ å…¥: WebSocket æœªè¿æ¥');
                }
            }

            ReGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'start_new_round',
                        player_id: this.playerId
                    };
                    console.log('Sending ReGame message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`è¯·æ±‚æ–°çš„æ¸¸æˆå›åˆ...`);
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•è¯·æ±‚æ–°å›åˆ: WebSocket æœªè¿æ¥');
                }
            }
            
            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    console.log('Message sent:', message);
                } else {
                    console.error('Cannot send message: WebSocket not open');
                    this.addToLog('é”™è¯¯: æ— æ³•å‘é€æ¶ˆæ¯ - è¿æ¥å·²å…³é—­');
                }
            }
            
            showCardDetail(card) {
                document.getElementById('detailCardName').textContent = card.name;
                document.getElementById('detailCardHP').textContent = card.HP || 0;
                document.getElementById('detailCardATK').textContent = card.ATK || 0;
                document.getElementById('detailCardProperty').textContent = card.property || "æ— ";
                document.getElementById('detailCardRace').textContent = card.race || "æ— ";
                
                // å¤„ç†è´¹ç”¨æ˜¾ç¤º
                let costText = "æ— ";
                if (card.cost && Array.isArray(card.cost)) {
                    costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                } else if (card.cost && typeof card.cost === 'object') {
                    costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                }
                document.getElementById('detailCardCost').textContent = costText;
                
                document.getElementById('cardDetailModal').style.display = 'flex';
            }
            
            renderCards() {
                const grid = document.getElementById('cardsGrid');
                grid.innerHTML = '';
                
                if (this.cards.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; width: 100%; color: #666; padding: 20px;">æš‚æ— å¡ç‰Œ</div>';
                    return;
                }
                
                // æ˜¾ç¤ºæ‰€æœ‰å¡ç‰Œï¼ŒåŒ…æ‹¬å·²ä½¿ç”¨çš„
                this.cards.forEach((card, index) => {
                    const uniqueId = `${card.name}_${index}`;
                    // this.addToLog(`uniqueId===: ${uniqueId}`);
                  
                    // åˆå§‹åŒ–å¡ç‰Œä½¿ç”¨çŠ¶æ€
                    if (!this.cardUsageMap.has(uniqueId)) {
                        this.cardUsageMap.set(uniqueId, {
                            card: card,
                            used: false,
                            slotIndex: -1
                        });
                    }
                    
                    const cardElement = this.createCardElement(card, index);
                    grid.appendChild(cardElement);
                });

                // å¾ªç¯ç»“æŸåæ‰“å°å®Œæ•´Map
                // this.addToLog('=== å®Œæ•´å¡ç‰‡ä½¿ç”¨çŠ¶æ€ ===');
                // this.cardUsageMap.forEach((value, key) => {
                //     this.addToLog(`å¡ç‰‡ID: ${key}, ä½¿ç”¨çŠ¶æ€: ${value.used}, å¡æ§½: ${value.slotIndex}, å¡ç‰‡å: ${value.card.name}`);
                // });
                
            }
            
            // ä¿®æ”¹createCardElementæ–¹æ³•ï¼Œä¸ºæœ‰"è¡€æ»´"è´¹ç”¨çš„å¡ç‰Œæ·»åŠ æ ‡è®°
            createCardElement(card, index, isSlotCard = false) {
                const uniqueId = `${card.name}_${index}`;
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.dataset.index = index;
                cardDiv.dataset.uniqueId = uniqueId;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰"è¡€æ»´"è´¹ç”¨
                const bloodCost = this.getBloodCost(card);
                if (bloodCost > 0) {
                    cardDiv.classList.add('has-blood-cost');
                    
                    // æ·»åŠ è¡€æ»´æ ‡è®°
                    const bloodIndicator = document.createElement('div');
                    bloodIndicator.className = 'blood-cost-indicator';
                    bloodIndicator.textContent = `ğŸ’‰${bloodCost}`;
                    bloodIndicator.title = `éœ€è¦ä¸¢å¼ƒ ${bloodCost} å¼ å¡ç‰Œä½œä¸ºè´¹ç”¨`;
                    cardDiv.appendChild(bloodIndicator);
                }
                
                // åªæœ‰åœ¨"your cards"ä¸­ä¸”æœªè¢«ä½¿ç”¨æ—¶æ‰å¯æ‹–åŠ¨
                if (!isSlotCard) {
                    const usage = this.cardUsageMap.get(uniqueId);
                    cardDiv.draggable = !(usage && usage.used);
                    
                    // å¦‚æœå¡ç‰Œå·²è¢«ä½¿ç”¨ï¼ˆåœ¨æ ä½ä¸­ï¼‰ï¼Œæ·»åŠ usedç±»ä½¿å…¶å˜ç°
                    if (usage && usage.used) {
                        cardDiv.classList.add('used');
                    }
                } else {
                    // æ ä½ä¸­çš„å¡ç‰Œä¸å¯æ‹–åŠ¨ï¼Œä½†ä¿æŒæ­£å¸¸æ˜¾ç¤º
                    cardDiv.draggable = false;
                    // æ ä½å¡ç‰Œæ·»åŠ ç‰¹å®šç±»
                    cardDiv.classList.add('slot-card-instance');
                }
                
                // åˆ›å»ºå¡ç‰Œå†…å®¹
                const cardHeader = document.createElement('div');
                cardHeader.className = 'card-header';
                cardHeader.textContent = card.name;
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';
                
                // å¡ç‰Œç»Ÿè®¡æ•°æ®
                const statsDiv = document.createElement('div');
                statsDiv.className = 'card-stats';
                
                const hpStat = document.createElement('div');
                hpStat.className = 'stat';
                hpStat.innerHTML = `<div class="stat-value">${card.HP || 0}</div><div class="stat-label">HP</div>`;
                
                const atkStat = document.createElement('div');
                atkStat.className = 'stat';
                atkStat.innerHTML = `<div class="stat-value">${card.ATK || 0}</div><div class="stat-label">ATK</div>`;
                
                statsDiv.appendChild(hpStat);
                statsDiv.appendChild(atkStat);
                
                // å¡ç‰Œå±æ€§
                const propertiesDiv = document.createElement('div');
                propertiesDiv.className = 'card-properties';
                
                if (card.race) {
                    const raceSpan = document.createElement('span');
                    raceSpan.className = 'property race';
                    raceSpan.textContent = card.race;
                    propertiesDiv.appendChild(raceSpan);
                }
                
                if (card.property) {
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'property type';
                    typeSpan.textContent = card.property;
                    propertiesDiv.appendChild(typeSpan);
                }
                
                // å¡ç‰Œè´¹ç”¨
                const costDiv = document.createElement('div');
                costDiv.className = 'card-cost';
                
                if (card.cost) {
                    let costText = "";
                    if (Array.isArray(card.cost)) {
                        costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                    } else if (typeof card.cost === 'object') {
                        costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                    }
                    if(!costText){
                        costDiv.textContent = "è´¹ç”¨: æ— ";
                    } else {
                        costDiv.textContent = `è´¹ç”¨: ${costText}`;
                    }
                } else {
                    costDiv.textContent = "è´¹ç”¨: æ— ";
                }
                
                // ç»„è£…å¡ç‰Œ
                cardBody.appendChild(statsDiv);
                cardBody.appendChild(propertiesDiv);
                
                cardDiv.appendChild(cardHeader);
                cardDiv.appendChild(cardBody);
                cardDiv.appendChild(costDiv);
                
                // å³é”®ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…
                cardDiv.oncontextmenu = (e) => {
                    e.preventDefault();
                    this.showCardDetail(card);
                    return false;
                };
                
                return cardDiv;
            }
            
            updateCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.slot');

                slots.forEach((slot, index) => {
                    const cards = this.currentRoundSlots[index];
                    
                    
                    // æ¸…é™¤æ—§å†…å®¹
                    slot.innerHTML = '';
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0 || cards.length > 1) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'slot-empty';
                        emptyDiv.textContent = 'æ‹–æ”¾å¡ç‰Œåˆ°è¿™é‡Œ';
                        this.currentRoundSlots[index]=[];
                        slot.appendChild(emptyDiv);
                        
                    }  else {


                        // åˆ›å»ºå¡ç‰Œå®¹å™¨
                        const cardsContainer = document.createElement('div');
                        cardsContainer.style.width = '100%';

                        if(cards.length === 2&&cards[1].cost){
                            this.addToLog('aaaaaaaaaaaaaaa');
                            
                            this.addToLog(`Cards in slot=== ${cards[0].name}`);
                            if (cards[0].cost && Array.isArray(cards[0].cost)) {
                                // æ˜¾ç¤ºæ‰€æœ‰æˆæœ¬é¡¹
                                cards[0].cost.forEach((costItem, index) => {
                                    this.addToLog(`æˆæœ¬[${index}]: ${costItem.amount} ${costItem.resource}`);
                                });
                              
                            } else {
                                this.addToLog('æˆæœ¬æ•°æ®æ ¼å¼é”™è¯¯æˆ–ä¸ºç©º');
                            }
                            
                            this.addToLog('endddd');
                        }
                        
                        cards.forEach((card, cardIndex) => {
                            const cardWrapper = document.createElement('div');
                            cardWrapper.style.position = 'relative';
                            cardWrapper.style.marginBottom = '10px';
                            
                            // åˆ›å»ºå®Œæ•´å¡ç‰Œå…ƒç´ ï¼ˆå’ŒYour Cardsä¸­çš„ä¸€æ ·ï¼‰
                            const cardElement = this.createCardElement(card, cardIndex);
                            cardElement.classList.add('slot-card');
                            cardElement.style.width = '170px';
                            cardElement.style.margin = '0 auto';
                            
                            cardWrapper.appendChild(cardElement);
                            cardsContainer.appendChild(cardWrapper);
                        });
                        
                        slot.appendChild(cardsContainer);
                    }
                    
                    // æ·»åŠ æ•´ä¸ªæ ä½çš„æ¸…é™¤æŒ‰é’®
                    const clearAllBtn = document.createElement('button');
                    clearAllBtn.className = 'clear-slot-btn';
                    clearAllBtn.innerHTML = 'Ã—';
                    clearAllBtn.title = 'æ¸…ç©ºæ•´ä¸ªæ ä½';
                    
                    clearAllBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeCardFromSlot(index);
                    });
                    
                    slot.appendChild(clearAllBtn);
                    
                    // é¼ æ ‡æ‚¬åœåœ¨æ ä½æ—¶æ˜¾ç¤ºæ¸…é™¤æŒ‰é’®
                    slot.addEventListener('mouseenter', () => {
                        if (cards.length > 0) {
                            clearAllBtn.style.display = 'block';
                        }
                    });
                    
                    slot.addEventListener('mouseleave', () => {
                        clearAllBtn.style.display = 'none';
                    });
                });
               
                document.getElementById('playButton').disabled = false;
            }
            
            updateOpponentCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.opponent-slot');
                slots.forEach((slot, index) => {
                    const cards = this.opponentCurrentRoundSlots[index];
                    
                    // æ¸…é™¤æ—§å†…å®¹
                    slot.innerHTML = '';
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'opponent-slot-empty';
                        emptyDiv.textContent = 'ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ';
                        slot.appendChild(emptyDiv);
                    } else {
                        // åˆ›å»ºå¡ç‰Œå®¹å™¨
                        const cardsContainer = document.createElement('div');
                        cardsContainer.style.width = '100%';
                        
                        cards.forEach((card, cardIndex) => {
                            const cardWrapper = document.createElement('div');
                            cardWrapper.style.position = 'relative';
                            cardWrapper.style.marginBottom = '10px';
                            
                            // åˆ›å»ºå®Œæ•´å¡ç‰Œå…ƒç´ 
                            const cardElement = this.createCardElement(card, cardIndex);
                            cardElement.classList.add('opponent-slot-card');
                            cardElement.style.width = '170px';
                            cardElement.style.margin = '0 auto';
                            cardElement.style.opacity = '0.9';
                            
                            cardWrapper.appendChild(cardElement);
                            cardsContainer.appendChild(cardWrapper);
                        });
                        
                        slot.appendChild(cardsContainer);
                    }
                });
            }
            
            // ä¿®æ”¹addCardToSlotæ–¹æ³•ï¼Œæ·»åŠ "è¡€æ»´"è´¹ç”¨æ£€æŸ¥
            addCardToSlot(slotIndex, cardData, discardedCards = []) {
                const uniqueId = cardData.uniqueId;
                
                // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²è¢«ä½¿ç”¨
                if (!this.cardUsageMap.has(uniqueId)) {
                    return false;
                }
                
                const usage = this.cardUsageMap.get(uniqueId);
                const card = cardData.card;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰"è¡€æ»´"è´¹ç”¨
                const bloodCost = this.getBloodCost(card);
                if (bloodCost > 0) {
                    // éœ€è¦ä¸¢å¼ƒå¡ç‰Œä½œä¸ºè´¹ç”¨
                    if (!this.handleBloodCostPayment(slotIndex, card, bloodCost, discardedCards)) {
                        this.addToLog(`âŒ éœ€è¦ä¸¢å¼ƒ ${bloodCost} å¼ å¡ç‰Œä½œä¸º"è¡€æ»´"è´¹ç”¨`);
                        return false;
                    }
                }
                
                // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²è¢«ä½¿ç”¨
                if (usage.used && usage.slotIndex !== slotIndex) {
                    // å¡ç‰Œå·²è¢«å…¶ä»–æ ä½ä½¿ç”¨ï¼Œå…ˆä»ä¸­ç§»é™¤
                    this.removeCardFromSlot(usage.slotIndex, uniqueId);
                }
                
                // å¦‚æœå·²ç»åœ¨åŒä¸€ä¸ªæ ä½ï¼Œä¸éœ€è¦é‡å¤æ·»åŠ 
                if (usage.used && usage.slotIndex === slotIndex) {
                    return true;
                }
                
                // æ·»åŠ åˆ°æŒ‡å®šæ ä½
                const cardInSlot = {
                    ...card,
                    uniqueId: uniqueId,
                    slotIndex: slotIndex
                };
                
                // ç§»é™¤è‡ªåŠ¨æ¸…ç©ºé€»è¾‘ï¼ˆå…è®¸ä¸€ä¸ªæ ä½æ”¾ç½®å¤šå¼ å¡ç‰Œï¼‰
                // if (this.currentRoundSlots[slotIndex].length > 0) {
                //     this.removeCardFromSlot(slotIndex);
                // }
                
                this.currentRoundSlots[slotIndex].push(cardInSlot);
                
                // æ›´æ–°å¡ç‰Œä½¿ç”¨çŠ¶æ€
                usage.used = true;
                usage.slotIndex = slotIndex;
                
                // å‘é€æ”¾ç½®æ›´æ–°ç»™å¯¹æ‰‹
                this.sendCardPlacementUpdate(slotIndex, card, 'add');
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
                return true;
            }

            // æ–°å¢ï¼šè·å–"è¡€æ»´"è´¹ç”¨æ•°é‡çš„æ–¹æ³•
            getBloodCost(card) {
                if (!card.cost) return 0;
                
                let totalBloodCost = 0;
                if (Array.isArray(card.cost)) {
                    card.cost.forEach(costItem => {
                        if (costItem.resource === "è¡€æ»´") {
                            totalBloodCost += costItem.amount || 0;
                        }
                    });
                }
                return totalBloodCost;
            }

            // æ–°å¢ï¼šå¤„ç†"è¡€æ»´"è´¹ç”¨æ”¯ä»˜çš„æ–¹æ³•
            handleBloodCostPayment(slotIndex, newCard, bloodCost, discardedCards) {
                if (bloodCost <= 0) return true;
                
                // è®¡ç®—å½“å‰æ‰€æœ‰æ ä½ä¸­çš„å¡ç‰Œæ•°é‡
                let totalAvailableCards = 0;
                for (let i = 0; i < 4; i++) {
                    totalAvailableCards += this.currentRoundSlots[i].length;
                }
                
                if (totalAvailableCards < bloodCost) {
                    this.addToLog(`âŒ å¯ä¸¢å¼ƒçš„å¡ç‰Œä¸è¶³: éœ€è¦ ${bloodCost} å¼ ï¼Œåªæœ‰ ${totalAvailableCards} å¼ å¯ç”¨`);
                    return false;
                }
                
                // å¦‚æœæä¾›äº†å·²ä¸¢å¼ƒçš„å¡ç‰Œåˆ—è¡¨ï¼Œç›´æ¥ä½¿ç”¨
                if (discardedCards && discardedCards.length >= bloodCost) {
                    // ä¸¢å¼ƒæŒ‡å®šçš„å¡ç‰Œ
                    this.discardCardsForBloodCost(discardedCards, bloodCost, slotIndex, newCard);
                    return true;
                }
                
                // å¦åˆ™éœ€è¦æç¤ºç”¨æˆ·é€‰æ‹©è¦ä¸¢å¼ƒçš„å¡ç‰Œ
                this.promptDiscardCards(bloodCost, slotIndex, newCard);
                return false; // ç­‰å¾…ç”¨æˆ·é€‰æ‹©
            }

            // æ–°å¢ï¼šæç¤ºç”¨æˆ·é€‰æ‹©è¦ä¸¢å¼ƒçš„å¡ç‰Œ
            promptDiscardCards(requiredAmount, targetSlotIndex, newCard) {
                const selectedDiscardCards = [];
                const discardModal = document.createElement('div');
                discardModal.id = 'discardModal';
                discardModal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    max-width: 500px;
                    width: 90%;
                    max-height: 80%;
                    overflow-y: auto;
                `;
                
                // æ”¶é›†æ‰€æœ‰å¯ä¸¢å¼ƒçš„å¡ç‰Œï¼ˆé™¤äº†æ–°å¡ç‰Œæœ¬èº«ï¼‰
                const availableCards = [];
                for (let i = 0; i < 4; i++) {
                    this.currentRoundSlots[i].forEach(card => {
                        if (card.name !== newCard.name) { // ä¸èƒ½ä¸¢å¼ƒè‡ªå·±
                            availableCards.push({
                                ...card,
                                originalSlotIndex: i
                            });
                        }
                    });
                }
                
                if (availableCards.length < requiredAmount) {
                    this.addToLog('âŒ å¯ä¸¢å¼ƒçš„å¡ç‰Œä¸è¶³');
                    return;
                }
                
                modalContent.innerHTML = `
                    <h3 style="color: #dc3545; margin-top: 0;">ğŸ’‰ è¡€æ»´è´¹ç”¨æ”¯ä»˜</h3>
                    <p>å¡ç‰Œ <strong>${newCard.name}</strong> éœ€è¦æ”¯ä»˜ <strong>${requiredAmount}</strong> ç‚¹"è¡€æ»´"è´¹ç”¨</p>
                    <p>è¯·é€‰æ‹© ${requiredAmount} å¼ å¡ç‰Œä½œä¸ºè´¹ç”¨ä¸¢å¼ƒï¼š</p>
                    <div id="discardCardsList" style="margin: 20px 0;"></div>
                    <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                        <button id="confirmDiscardBtn" style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">ç¡®è®¤ä¸¢å¼ƒ</button>
                        <button id="cancelDiscardBtn" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">å–æ¶ˆ</button>
                    </div>
                `;
                
                discardModal.appendChild(modalContent);
                document.body.appendChild(discardModal);
                
                const cardsList = modalContent.querySelector('#discardCardsList');
                
                // æ˜¾ç¤ºå¯é€‰çš„å¡ç‰Œ
                availableCards.forEach(card => {
                    const cardElement = document.createElement('div');
                    cardElement.style.cssText = `
                        border: 2px solid #ddd;
                        border-radius: 5px;
                        padding: 10px;
                        margin: 5px 0;
                        cursor: pointer;
                        transition: all 0.2s;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    `;
                    
                    cardElement.innerHTML = `
                        <span><strong>${card.name}</strong> (æ ä½ ${card.originalSlotIndex + 1})</span>
                        <span id="checkmark_${card.uniqueId}" style="display: none;">âœ“</span>
                    `;
                    
                    cardElement.onclick = () => {
                        const index = selectedDiscardCards.findIndex(c => c.uniqueId === card.uniqueId);
                        const checkmark = cardElement.querySelector(`#checkmark_${card.uniqueId}`);
                        
                        if (index === -1) {
                            if (selectedDiscardCards.length < requiredAmount) {
                                selectedDiscardCards.push(card);
                                cardElement.style.borderColor = '#dc3545';
                                cardElement.style.background = '#fff5f5';
                                checkmark.style.display = 'inline';
                                checkmark.style.color = '#dc3545';
                            }
                        } else {
                            selectedDiscardCards.splice(index, 1);
                            cardElement.style.borderColor = '#ddd';
                            cardElement.style.background = 'white';
                            checkmark.style.display = 'none';
                        }
                        
                        // æ›´æ–°æŒ‰é’®çŠ¶æ€
                        const confirmBtn = document.getElementById('confirmDiscardBtn');
                        confirmBtn.disabled = selectedDiscardCards.length !== requiredAmount;
                    };
                    
                    cardsList.appendChild(cardElement);
                });
                
                // ç¡®è®¤æŒ‰é’®äº‹ä»¶
                modalContent.querySelector('#confirmDiscardBtn').onclick = () => {
                    if (selectedDiscardCards.length === requiredAmount) {
                        // æ‰§è¡Œä¸¢å¼ƒå¹¶æ”¾ç½®æ–°å¡ç‰Œ
                        this.discardCardsForBloodCost(selectedDiscardCards, requiredAmount, targetSlotIndex, newCard);
                        document.body.removeChild(discardModal);
                    }
                };
                
                // å–æ¶ˆæŒ‰é’®äº‹ä»¶
                modalContent.querySelector('#cancelDiscardBtn').onclick = () => {
                    document.body.removeChild(discardModal);
                    this.addToLog('å·²å–æ¶ˆæ”¾ç½®å¡ç‰Œ');
                };
            }

            // æ–°å¢ï¼šæ‰§è¡Œä¸¢å¼ƒå¡ç‰Œçš„æ–¹æ³•
            discardCardsForBloodCost(discardedCards, bloodCost, targetSlotIndex, newCard) {
                // è®°å½•ä¸¢å¼ƒçš„å¡ç‰Œä¿¡æ¯
                const discardDetails = discardedCards.map(card => ({
                    name: card.name,
                    HP: card.HP,
                    ATK: card.ATK,
                    slotIndex: card.originalSlotIndex,
                    uniqueId: card.uniqueId
                }));
                
                // å‘é€ä¸¢å¼ƒä¿¡æ¯ç»™æœåŠ¡å™¨
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const discardMsg = {
                        type: 'blood_cost_discard',
                        player_id: this.playerId,
                        discarded_cards: discardDetails,
                        new_card: {
                            name: newCard.name,
                            HP: newCard.HP,
                            ATK: newCard.ATK,
                            cost: newCard.cost,
                            id: newCard.card_id
                        },
                        target_slot: targetSlotIndex,
                        blood_cost_paid: bloodCost
                    };
                    
                    this.sendMessage(discardMsg);
                    this.addToLog(`ğŸ’‰ ä¸¢å¼ƒå¡ç‰Œä½œä¸º"è¡€æ»´"è´¹ç”¨: ${discardDetails.map(c => c.name).join(', ')}`);
                }
                
                // ä»æ ä½ä¸­ç§»é™¤ä¸¢å¼ƒçš„å¡ç‰Œ
                discardedCards.forEach(card => {
                    // æ›´æ–°å¡ç‰Œä½¿ç”¨çŠ¶æ€
                    if (this.cardUsageMap.has(card.uniqueId)) {
                        const usage = this.cardUsageMap.get(card.uniqueId);
                        usage.used = false;
                        usage.slotIndex = -1;
                    }
                    
                    // ä»æ ä½ä¸­ç§»é™¤
                    const slotCards = this.currentRoundSlots[card.originalSlotIndex];
                    const cardIndex = slotCards.findIndex(c => c.uniqueId === card.uniqueId);
                    if (cardIndex !== -1) {
                        slotCards.splice(cardIndex, 1);
                    }
                });
                
                // ä»å¡ç‰Œåˆ—è¡¨ä¸­ç§»é™¤ä¸¢å¼ƒçš„å¡ç‰Œï¼ˆæ°¸ä¹…ç§»é™¤ï¼‰
                discardedCards.forEach(card => {
                    const cardIndex = this.cards.findIndex(c => 
                        c.name === card.name && c.HP === card.HP && c.ATK === card.ATK
                    );
                    if (cardIndex !== -1) {
                        this.cards.splice(cardIndex, 1);
                    }
                });
            }

            
            removeCardFromSlot(slotIndex, specificUniqueId = null) {
                if (this.currentRoundSlots[slotIndex].length === 0) return;
                
                if (specificUniqueId !== null) {
                    // ç§»é™¤ç‰¹å®šå¡ç‰Œ
                    const cardIndex = this.currentRoundSlots[slotIndex].findIndex(
                        card => card.uniqueId === specificUniqueId
                    );
                    if (cardIndex !== -1) {
                        const removedCard = this.currentRoundSlots[slotIndex][cardIndex];
                        this.currentRoundSlots[slotIndex].splice(cardIndex, 1);
                        
                        // æ›´æ–°å¡ç‰Œä½¿ç”¨çŠ¶æ€
                        if (this.cardUsageMap.has(removedCard.uniqueId)) {
                            const usage = this.cardUsageMap.get(removedCard.uniqueId);
                            usage.used = false;
                            usage.slotIndex = -1;
                        }
                        
                        // å‘é€ç§»é™¤æ›´æ–°ç»™å¯¹æ‰‹
                        this.sendCardPlacementUpdate(slotIndex, removedCard, 'remove');
                    }
                } else {
                    // ç§»é™¤æ•´ä¸ªæ ä½çš„æ‰€æœ‰å¡ç‰Œ
                    const removedCards = [...this.currentRoundSlots[slotIndex]];
                    this.currentRoundSlots[slotIndex] = [];
                    
                    // æ›´æ–°æ‰€æœ‰å¡ç‰Œçš„ä½¿ç”¨çŠ¶æ€
                    removedCards.forEach(card => {
                        if (this.cardUsageMap.has(card.uniqueId)) {
                            const usage = this.cardUsageMap.get(card.uniqueId);
                            usage.used = false;
                            usage.slotIndex = -1;
                        }
                    });
                }
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }
            
            playCurrentRoundCards() {
                if (!this.connected ) {
                    this.addToLog('âŒè¿æ¥å¤±è´¥');
                    return;
                }
                
                // æ”¶é›†æ‰€æœ‰æ ä½çš„å¡ç‰Œ
                const allCards = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    const slotCards = this.currentRoundSlots[i].map(card => {
                        return {
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            cost: card.cost,
                            id:card.card_id

                        };
                    });
                    allCards.push(...slotCards);
                }
                
                if (allCards.length === 0) {
                    this.addToLog('å·²ç»“æŸï¼Œæ²¡æœ‰å‡ºç‰Œ');
                    document.getElementById('playButton').disabled = true;
                }
                
                // è®°å½•å“ªäº›å¡ç‰Œè¢«æ‰“å‡ºäº†ï¼ˆæ°¸ä¹…ç§»é™¤ï¼‰
                const playedUniqueIds = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    this.currentRoundSlots[i].forEach(card => {
                        playedUniqueIds.push(card.uniqueId);
                    });
                }
                
                const playMsg = {
                    type: 'player_action',
                    player_id: this.playerId,
                    cards: allCards.map(card => card.name),
                    slots: this.currentRoundSlots.map(slot => 
                        slot.map(card => ({
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            id:card.card_id
                        }))
                    ),
                    card_details: allCards
                };
                
                console.log('Sending play message:', playMsg);
                this.sendMessage(playMsg);
                this.addToLog(`æ‰“å‡ºå¡ç‰Œ: ${allCards.map(c => c.name).join(', ')}`);
                
                // ä»å¡ç‰Œåˆ—è¡¨ä¸­æ°¸ä¹…ç§»é™¤æ‰“å‡ºçš„å¡ç‰Œ
                this.cards = this.cards.filter((card, index) => {
                    const uniqueId = `${card.name}_${index}`;
                    return !playedUniqueIds.includes(uniqueId);
                });
                
                // æ¸…é™¤å¡ç‰Œä½¿ç”¨çŠ¶æ€
                playedUniqueIds.forEach(uniqueId => {
                    this.cardUsageMap.delete(uniqueId);
                });
                
                // // é‡ç½®å½“å‰å›åˆæ ä½
                // this.lastClickedCard = null;
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }
            
            updateStatus(message, type) {
                const statusDiv = document.getElementById('connectionStatus');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
            }
            
            addToLog(message) {
                const logDiv = document.getElementById('gameLog');
                const timestamp = new Date().toLocaleTimeString();
                logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.min(1000 * this.reconnectAttempts, 10000);
                    
                    console.log(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts})`);
                    this.updateStatus(`ğŸ”„ é‡æ–°è¿æ¥ä¸­... (å°è¯• ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'info');
                    
                    setTimeout(() => {
                        this.connect();
                    }, delay);
                } else {
                    console.error('Max reconnection attempts reached');
                    this.updateStatus('âŒ è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€å’ŒIPåœ°å€', 'error');
                }
            }
        }
        
        let gameClient;
        
        // å…¨å±€æ‹–æ”¾å¤„ç†å‡½æ•°
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('highlight');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('highlight');
        }
        
        // ä¿®æ”¹handleDropå‡½æ•°ï¼Œæ”¯æŒä¸¢å¼ƒå¡ç‰Œ
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('highlight');
            
            try {
                const data = JSON.parse(e.dataTransfer.getData('application/json'));
                const slotIndex = parseInt(e.currentTarget.dataset.slotIndex);
                
                console.log('Drop data:', data); // è°ƒè¯•æ—¥å¿—
                console.log('Target slot:', slotIndex); // è°ƒè¯•æ—¥å¿—
                
                if (!gameClient) {
                    console.error('gameClient not found');
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰"è¡€æ»´"è´¹ç”¨
                const bloodCost = gameClient.getBloodCost(data.card);
                if (bloodCost > 0) {
                    // éœ€è¦ç”¨æˆ·é€‰æ‹©ä¸¢å¼ƒå“ªäº›å¡ç‰Œ
                    gameClient.promptDiscardCards(bloodCost, slotIndex, data.card);
                    return;
                }
                
                // æ²¡æœ‰"è¡€æ»´"è´¹ç”¨ï¼Œç›´æ¥æ”¾ç½®
                const success = gameClient.addCardToSlot(slotIndex, data);
                if (success) {
                    console.log(`Card ${data.card.name} added to slot ${slotIndex}`);
                } else {
                    console.error('Failed to add card to slot');
                }
            } catch (error) {
                console.error('Drop error:', error);
            }
        }

        // åœ¨CSSä¸­æ·»åŠ æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
            .blood-cost-indicator {
                position: absolute;
                top: -10px;
                right: -10px;
                background: #dc3545;
                color: white;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                z-index: 2;
            }
            
            .card.has-blood-cost {
                border: 2px solid #dc3545 !important;
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
            }
            
            .card.has-blood-cost .card-header {
                background: linear-gradient(135deg, #dc3545, #c82333) !important;
            }
        `;
        document.head.appendChild(style);
                
        // function handleSlotClick(slotIndex) {
        //     if (gameClient && gameClient.lastClickedCard) {
        //         gameClient.addCardToSlot(slotIndex, gameClient.lastClickedCard);
        //         gameClient.lastClickedCard = null;
        //     }
        // }
        
        function clearSlot(slotIndex, uniqueId = null, e = null) {
            if (e) e.stopPropagation();
            if (gameClient) {
                if (uniqueId) {
                    // æ¸…é™¤ç‰¹å®šå¡ç‰Œ
                    gameClient.removeCardFromSlot(slotIndex, uniqueId);
                } else {
                    // æ¸…é™¤æ•´ä¸ªæ ä½
                    gameClient.removeCardFromSlot(slotIndex);
                }
            }
        }
        
        // æ–°å¢ï¼šå‘é€ç‰¹æ®Šæ“ä½œçš„å…¨å±€å‡½æ•°
        function sendSpecialAction(actionType) {
            if (gameClient) {
                gameClient.sendSpecialAction(actionType);
            }
        }
        
        function playCurrentRoundCards() {
            if (gameClient) {
                gameClient.playCurrentRoundCards();
            }
        }
        
        function closeCardDetail() {
            document.getElementById('cardDetailModal').style.display = 'none';
        }
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('cardDetailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCardDetail();
            }
        });
        
        window.onload = function() {
            gameClient = new GameClient();
        };
        
        function joinGame() {
            if (gameClient) {
                gameClient.joinGame();
            }
        }

        function ReGame() {
            if (gameClient) {
                gameClient.ReGame();
            }
        }
        
        function updateServerIP() {
            if (gameClient) {
                gameClient.reconnectAttempts = 0;
                gameClient.connect();
            }
        }
    </script>
</body>
</html>