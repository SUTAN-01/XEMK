<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XEMK</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .game-container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .player-section { border: 2px solid #333; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .cards-grid { display: flex; flex-wrap: wrap; gap: 15px; margin: 10px 0; }
        .card { 
            width: 180px; 
            display: flex; flex-direction: column;
            border: 2px solid #007bff; border-radius: 8px;
            cursor: grab; background: white; transition: all 0.2s;
            user-select: none; overflow: hidden;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .card.selected { border-color: #28a745; box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3); }
        .card.used { 
            opacity: 0.5; 
            cursor: not-allowed;
            filter: grayscale(80%);
            background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
        }
        .card.dragging {
            opacity: 0.7;
            transform: scale(1.05);
        }
        
        /* å¡ç‰Œå†…éƒ¨æ ·å¼ */
        .card-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        .card.used .card-header {
            background: linear-gradient(135deg, #6c757d, #495057);
        }
        
        .card-body {
            padding: 10px;
            flex-grow: 1;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        
        .card-properties {
            margin-top: 8px;
            font-size: 14px;
        }
        
        .property {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 4px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .property.race {
            background: #d4edda;
            color: #155724;
        }
        
        .property.type {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .card-cost {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .cost-item {
            display: inline-block;
            margin-right: 5px;
            color: #6c757d;
        }
        
        .controls { margin: 15px 0; text-align: center; }
        button { 
            padding: 12px 24px; margin: 5px; cursor: pointer; 
            background: #28a745; color: white; border: none; border-radius: 5px;
            font-size: 16px; transition: background 0.2s;
        }
        button:hover { background: #218838; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        #gameLog { 
            height: 200px; overflow-y: auto; border: 1px solid #ccc; 
            padding: 10px; margin: 10px 0; background-color: #f8f9fa;
            border-radius: 5px; font-family: monospace;
        }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .config-section { background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px; margin: 10px 0; }
        
        /* æ–°æ·»åŠ çš„ï¼šç‰¹æ®Šæ“ä½œæŒ‰é’®å®¹å™¨æ ·å¼ */
        .special-actions-container {
            margin-top: 15px;
            display: none; /* é»˜è®¤éšè—ï¼Œæ¥æ”¶åˆ°æŒ‡ä»¤åæ˜¾ç¤º */
        }
        
        .special-actions-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .special-actions-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .special-action-box {
            width: 180px;
            height: 240px;
            border: 3px dashed #007bff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        
        .special-action-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
            border-color: #0056b3;
            background-color: #f0f8ff;
        }
        
        .special-action-box.option1 {
            border-color: #ff6b6b;
        }
        
        .special-action-box.option2 {
            border-color: #4ecdc4;
        }
        
        .special-action-box.option1:hover {
            background-color: #fff0f0;
        }
        
        .special-action-box.option2:hover {
            background-color: #f0fafa;
        }
        
        .special-action-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .special-action-text {
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            padding: 0 10px;
        }
        
        .special-action-desc {
            font-size: 12px;
            color: #666;
            text-align: center;
            padding: 0 10px;
            margin-top: 8px;
        }
        
        /* å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œæ ·å¼ */
        .current-round-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }
        
        .current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slot {
            width: 80%;
            min-height: 180px;
            border: 3px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: white;
            transition: all 0.2s;
            position: relative;
            padding: 10px;
            overflow-y: auto;
        }
        
        .slot.highlight {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .slot-card {
            width: 170px;
            margin-bottom: 10px;
        }
        
        .slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        .clear-slot-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: #ffc107;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            display: none;
            z-index: 5;
        }
        
        .clear-slot-btn:hover {
            background: #e0a800 !important;
        }
        
        .clear-single-card-btn:hover {
            background: #c82333 !important;
        }
        
        .slot:hover .clear-slot-btn {
            display: block;
        }
        
        /* å¯¹æ–¹å½“å‰å›åˆæ ·å¼ */
        .opponent-current-round-section {
            margin-top: 30px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            border: 2px solid #ced4da;
        }
        
        .opponent-current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .opponent-slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .opponent-slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .opponent-slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .opponent-slot {
            width: 80%;
            min-height: 180px;
            border: 3px solid #6c757d;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: #f8f9fa;
            padding: 10px;
            overflow-y: auto;
        }
        
        .opponent-slot-card {
            width: 170px;
            margin-bottom: 10px;
            opacity: 0.9;
        }
        
        .opponent-slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        /* å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— */
        .card-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .card-detail-content {
            background: white;
            border-radius: 10px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .card-detail-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .card-detail-body {
            padding: 20px;
        }
        
        .detail-row {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .detail-label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }
        
        .detail-value {
            font-size: 16px;
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="text-align: center; color: #333;">ğŸƒ XEMK</h1>
        
        <div class="config-section">
            <h3>âš™ï¸ è¿æ¥è®¾ç½®</h3>
            <label for="serverIP">æ¸¸æˆæœåŠ¡å™¨IPåœ°å€:</label>
            <input type="text" id="serverIP" value="10.2.3.31" style="padding: 5px; margin: 0 10px;">
            <button onclick="updateServerIP()">æ›´æ–°è¿æ¥</button>
            <p><small>æç¤º: åœ¨ROS 2ä¸»æœºä¸Šè¿è¡Œ <code>hostname -I</code> æŸ¥çœ‹IPåœ°å€</small></p>
            
            <!-- æ–°å¢çš„ç‰¹æ®Šæ“ä½œæŒ‰é’®åŒºåŸŸ -->
            <div class="special-actions-container" id="specialActionsContainer">
                <div class="special-actions-title">âš¡ ç‰¹æ®Šæ“ä½œ</div>
                <div class="special-actions-buttons">
                    <div class="special-action-box option1" onclick="sendSpecialAction('squirrels')">
                        <div class="special-action-icon">ğŸ”µ</div>
                        <div class="special-action-text">æ¾é¼ </div>
                        <div class="special-action-desc">é€‰æ‹©æ¾é¼ ç‰Œ</div>
                    </div>
                    <div class="special-action-box option2" onclick="sendSpecialAction('creations')">
                        <div class="special-action-icon">ğŸ”´</div>
                        <div class="special-action-text">é€ ç‰©</div>
                        <div class="special-action-desc">é€‰æ‹©é€ ç‰©ç‰Œ</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="connectionStatus" class="status info">å‡†å¤‡è¿æ¥...</div>
        
        <div class="player-section">
            <h2>ğŸƒ Your Cards</h2>
            <div id="cardsGrid" class="cards-grid">No cards yet. Join the game first.</div>
            
            <!-- å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œï¼ˆå¯æ”¾ç½®åŒºåŸŸï¼‰ -->
            <div class="current-round-section">
                <h3>å½“å‰å›åˆè¦ä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="slot-container">
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 1</div>
                        <div class="slot" data-slot-index="0" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(0)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 2</div>
                        <div class="slot" data-slot-index="1" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(1)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 3</div>
                        <div class="slot" data-slot-index="2" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(2)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 4</div>
                        <div class="slot" data-slot-index="3" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(3)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ -->
            <div class="opponent-current-round-section">
                <h3>å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="opponent-slot-container">
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 1</div>
                        <div class="opponent-slot" data-opponent-slot-index="0">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 2</div>
                        <div class="opponent-slot" data-opponent-slot-index="1">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 3</div>
                        <div class="opponent-slot" data-opponent-slot-index="2">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 4</div>
                        <div class="opponent-slot" data-opponent-slot-index="3">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="joinButton" onclick="joinGame()">åŠ å…¥æ¸¸æˆ</button>
                <button id="endButton" onclick="ReGame()">é‡æ–°å¼€å§‹</button>
                <button id="playButton" onclick="playCurrentRoundCards()" disabled>ç»“æŸå·±æ–¹å›åˆ</button>
                <!-- <button id="skipButton" onclick="skip()" disabled>è·³è¿‡</button> -->
            </div>
        </div>
        
        <div class="player-section">
            <h2>ğŸ“ æ¸¸æˆæ—¥å¿—</h2>
            <div id="gameLog">æ¸¸æˆæ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        </div>
    </div>

    <!-- å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— -->
    <div class="card-detail-modal" id="cardDetailModal">
        <div class="card-detail-content">
            <div class="card-detail-header">
                <span id="detailCardName">å¡ç‰Œåç§°</span>
                <button class="close-modal" onclick="closeCardDetail()">Ã—</button>
            </div>
            <div class="card-detail-body">
                <div class="detail-row">
                    <div class="detail-label">ç”Ÿå‘½å€¼ (HP)</div>
                    <div class="detail-value" id="detailCardHP">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">æ”»å‡»åŠ› (ATK)</div>
                    <div class="detail-value" id="detailCardATK">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">å±æ€§</div>
                    <div class="detail-value" id="detailCardProperty">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">ç§æ—</div>
                    <div class="detail-value" id="detailCardRace">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">è´¹ç”¨</div>
                    <div class="detail-value" id="detailCardCost">æ— </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GameClient {
            constructor() {
                this.ws = null;
                this.playerId = null;
                this.cards = []; // å­˜å‚¨å¡ç‰Œå¯¹è±¡æ•°ç»„
                this.connected = false;
                this.serverIP = '10.2.3.31';
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.round = 0;
                this.currentRound = 0;
                this.skip = '';
                
                // å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.currentRoundSlots = [[], [], [], []];
                // å¯¹æ–¹å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.opponentCurrentRoundSlots = [[], [], [], []];
                // æœ€è¿‘ç‚¹å‡»çš„å¡ç‰Œï¼ˆç”¨äºç‚¹å‡»æ”¾ç½®ï¼‰
                this.lastClickedCard = null;
                // å¡ç‰Œä½¿ç”¨çŠ¶æ€æ˜ å°„
                this.cardUsageMap = new Map(); // æ ¼å¼: uniqueId -> {card: object, used: boolean, slotIndex: number}
                // ç”¨äºåŒæ­¥å¯¹æ–¹æ˜¾ç¤ºçš„ä¸´æ—¶æ•°æ®
                this.pendingOpponentCards = [[], [], [], []];
                
                // ä»URLè·å–ç©å®¶ID
                const urlParams = new URLSearchParams(window.location.search);
                this.playerId = urlParams.get('player') || 'player1';
                
                // è®¾ç½®IPè¾“å…¥æ¡†çš„é»˜è®¤å€¼
                document.getElementById('serverIP').value = this.getDefaultIP();
                
                this.connect();
                this.initDragAndDrop();
            }
            
            getDefaultIP() {
                return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                    ? 'localhost' 
                    : '10.2.3.31';
            }
            
            initDragAndDrop() {
                // å¡ç‰Œæ‹–åŠ¨äº‹ä»¶
                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('card') && !e.target.classList.contains('used')) {
                        const cardIndex = parseInt(e.target.dataset.index);
                        const uniqueId = e.target.dataset.uniqueId;
                        const usage = this.cardUsageMap.get(uniqueId);
                        const card = usage ? usage.card : this.cards[cardIndex];
                        
                        e.dataTransfer.setData('application/json', JSON.stringify({
                            card: card,
                            index: cardIndex,
                            uniqueId: uniqueId
                        }));
                        e.target.classList.add('dragging');
                    }
                });
                
                document.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('card')) {
                        e.target.classList.remove('dragging');
                    }
                });
            }
            
            connect() {
                if (this.ws) {
                    this.ws.close();
                }
                
                this.serverIP = document.getElementById('serverIP').value || this.getDefaultIP();
                const wsUrl = `ws://${this.serverIP}:8002`;
                
                try {
                    this.updateStatus(`ğŸ”— æ­£åœ¨è¿æ¥åˆ° ${this.serverIP}:8002`, 'info');
                    console.log('Connecting to:', wsUrl);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to game server');
                        this.isConnected = true;
                        this.connected = true;
                        this.reconnectAttempts = 0;
                        this.updateStatus('âœ… å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨', 'success');
                        this.addToLog('å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨ ' + this.serverIP);
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event);
                        this.isConnected = false;
                        this.connected = false;
                        
                        if (!event.wasClean) {
                            this.handleReconnect();
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('âŒ è¿æ¥é”™è¯¯', 'error');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            console.log('Raw message received:', event.data);
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            console.error('Error parsing message:', e);
                            this.addToLog('è§£ææœåŠ¡å™¨æ¶ˆæ¯æ—¶å‡ºé”™: ' + e.message);
                        }
                    };
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateStatus('âŒ åˆ›å»ºè¿æ¥å¤±è´¥', 'error');
                    this.handleReconnect();
                }
            }
            
            handleMessage(data) {
                console.log('Parsed message:', data);
                
                switch(data.type) {
                    case 'numbers_assigned':
                        // æœåŠ¡å™¨è¿”å›çš„æ˜¯å¡ç‰Œæ•°ç»„
                        this.cards = data.cards || [];
                        // this.cards_ip = data.cards_ip || [];
                        // é‡ç½®å¡ç‰Œä½¿ç”¨çŠ¶æ€
                        this.cardUsageMap.clear();
                        this.renderCards();
                        this.updateCurrentRoundDisplay();
                        this.updateOpponentCurrentRoundDisplay();
                        this.updateStatus('âœ… å¡ç‰Œåˆ†é…å®Œæˆ! æ¸¸æˆå‡†å¤‡å°±ç»ª', 'success');
                        
                        // æ˜¾ç¤ºå¡ç‰Œåç§°
                        const cardNames = this.cards.map(card => card.name).join(', ');
                        this.addToLog(`ä½ è·å¾—äº† ${this.cards.length} å¼ å¡ç‰Œ: ${cardNames}`);
                        
                        if (this.round % 2 === 0) {
                            this.currentRound = this.round / 2;
                            this.addToLog(`å›åˆ ${this.currentRound}`);
                        }
                        this.round += 1;
                        break;
                        
                    case 'game_start':
                        this.addToLog('ğŸ® æ¸¸æˆå¼€å§‹! åŒæ–¹ç©å®¶å·²å°±ä½');
                        this.addToLog(`ä¸Šæ¬¡å‡ºç‰Œ: ${data.last_player}`);
                        this.cardUsageMap.clear();
                        this.currentRoundSlots = [[], [], [], []];
                        this.opponentCurrentRoundSlots = [[], [], [], []];
                        this.pendingOpponentCards = [[], [], [], []];
                        this.renderCards();
                        this.updateCurrentRoundDisplay();
                        this.updateOpponentCurrentRoundDisplay();
                        break;
                        
                    // case 'move_accepted':
                    //     // å¤„ç†è‡ªå·±æ‰“å‡ºçš„å¡ç‰Œ
                    //     this.addToLog(`âœ… ${data.message}`);
                        
                    //     // ä»cardsä¸­ç§»é™¤å·²ä½¿ç”¨çš„å¡ç‰Œ
                    //     if (data.cards_played && data.cards_played.length > 0) {
                    //         const playedCards = data.cards_played;
                    //         this.cards = this.cards.filter(card => 
                    //             !playedCards.includes(card.id)
                    //         );
                    //         this.renderCards();
                    //         //æ›´æ–°å½“å‰å›åˆæ 
                    //         this.updateCurrentRoundDisplay();
                    //     }
                    //     break;

                    case 'move_accepted':
                        this.addToLog(`âœ… ${data.message}`);
                        
                        if (data.cards_played && Array.isArray(data.cards_played)) {
                            // æ¸…ç©ºå½“å‰å›åˆæ‰€æœ‰æ ä½
                            this.currentRoundSlots = [[], [], [], []];
                            
                            // è®¡ç®—æ¯ä¸ªæ ä½çš„å¡ç‰Œæ•°é‡ï¼ˆå‡è®¾æœåŠ¡å™¨æŒ‰é¡ºåºè¿”å›å¡ç‰Œï¼‰
                            let currentSlotIndex = 0;
                            let currentSlotCount = 0;
                            
                            data.cards_played.forEach((cardData, index) => {
                                // è·³è¿‡nullå€¼ï¼ˆæœåŠ¡å™¨å¯èƒ½å‘é€nullè¡¨ç¤ºç©ºä½ï¼‰
                                if (cardData === null) {
                                    // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ ä½
                                    currentSlotIndex++;
                                    currentSlotCount = 0;
                                    return;
                                }
                                
                                // å¦‚æœæœ‰æ˜ç¡®çš„slot_indexä¿¡æ¯ï¼Œä½¿ç”¨å®ƒ
                                if (cardData.slot_index !== undefined && cardData.slot_index >= 0 && cardData.slot_index < 4) {
                                    this.currentRoundSlots[cardData.slot_index].push(cardData);
                                } else {
                                    // é»˜è®¤æŒ‰é¡ºåºåˆ†é…å¡ç‰Œåˆ°æ ä½
                                    // å‡è®¾æ¯ä¸ªæ ä½æœ€å¤šæ”¾ä¸€ä¸ªå¡ç‰Œï¼ˆæˆ–æ ¹æ®å½“å‰å¸ƒå±€ï¼‰
                                    // ä¿®å¤è¿™é‡Œçš„æ‹¼å†™é”™è¯¯
                                    this.currentRoundSlots[currentSlotIndex].push(cardData); // è¿™é‡Œä¿®å¤
                                    currentSlotCount++;
                                    
                                    // å¦‚æœå½“å‰æ ä½è¾¾åˆ°é™åˆ¶ï¼Œç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ ä½
                                    if (currentSlotCount >= 1) { // å‡è®¾æ¯ä¸ªæ ä½æœ€å¤š1å¼ å¡ç‰Œ
                                        currentSlotIndex++;
                                        currentSlotCount = 0;
                                    }
                                }
                                
                                // ç¡®ä¿ä¸ä¼šè¶…è¿‡4ä¸ªæ ä½
                                if (currentSlotIndex >= 4) {
                                    currentSlotIndex = 3; // ä¿æŒåœ¨æœ€åä¸€ä¸ªæ ä½
                                }
                            });
                            
                            // ä»æ‰‹ç‰Œä¸­ç§»é™¤å·²ä½¿ç”¨çš„å¡ç‰Œï¼ˆæ ¹æ®card_idï¼‰
                            const usedCardIds = [];
                            data.cards_played.forEach(cardData => {
                                if (cardData !== null && cardData.id) {
                                    usedCardIds.push(cardData.id);
                                }
                            });
                            
                            // æ›´æ–°æ‰‹ç‰Œï¼šç§»é™¤å·²ä½¿ç”¨çš„å¡ç‰Œ
                            if (usedCardIds.length > 0) {
                                this.cards = this.cards.filter(card => {
                                    const cardId = card.card_id || card.id;
                                    const isUsed = usedCardIds.includes(cardId);
                                    
                                    if (isUsed) {
                                        // ä»cardUsageMapä¸­åˆ é™¤
                                        const cardIndex = this.cards.indexOf(card);
                                        const uniqueId = `${card.name}_${cardIndex}`;
                                        this.cardUsageMap.delete(uniqueId);
                                    }
                                    
                                    return !isUsed;
                                });
                            }
                            
                            // é‡ç½®cardUsageMapä¸­å·²ä½¿ç”¨å¡ç‰Œçš„çŠ¶æ€ï¼ˆå› ä¸ºå·²ç»ç§»é™¤äº†ï¼‰
                            // é‡æ–°åˆ›å»ºå½“å‰æ ä½ä¸­å¡ç‰Œçš„ä½¿ç”¨çŠ¶æ€
                            for (let slotIndex = 0; slotIndex < this.currentRoundSlots.length; slotIndex++) {
                                const slotCards = this.currentRoundSlots[slotIndex];
                                
                                slotCards.forEach((card, cardIndex) => {
                                    if (card && card.id) {
                                        // ä¸ºæ ä½ä¸­çš„å¡ç‰Œåˆ›å»ºæ–°çš„ä½¿ç”¨çŠ¶æ€
                                        const uniqueId = `slot_${slotIndex}_${card.id}_${cardIndex}`;
                                        if (!this.cardUsageMap.has(uniqueId)) {
                                            this.cardUsageMap.set(uniqueId, {
                                                card: card,
                                                used: true,
                                                slotIndex: slotIndex
                                            });
                                        }
                                    }
                                });
                            }
                            
                            this.renderCards();
                            this.updateCurrentRoundDisplay();
                        }
                        break;
                        
                    case 'opponent_move':
                        // å¤„ç†å¯¹æ–¹æ‰“å‡ºçš„å¡ç‰Œ
                        if (data.cards_played && data.cards_played.length > 0) {
                            // è·å–å¡ç‰Œåç§°åˆ—è¡¨
                            const cardNames = data.cards_played.map(card => card.name).join(', ');
                            
                            // æ›´æ–°æ—¥å¿—
                            this.addToLog(`å¯¹æ–¹æ‰“å‡ºå¡ç‰Œ: ${cardNames}`);
                            
                            // å¦‚æœæœ‰æ˜ç¡®çš„æ ä½åˆ†é…ä¿¡æ¯ï¼Œä½¿ç”¨å®ƒ
                            if (data.slots && Array.isArray(data.slots)) {
                                this.addToLog(`æœ‰æ˜ç¡®çš„æ ä½åˆ†é…ä¿¡æ¯`);
                                for (let i = 0; i < Math.min(data.slots.length, 4); i++) {
                                    this.opponentCurrentRoundSlots[i] = data.slots[i] || [];
                                }
                            } else {
                                // å¦åˆ™é»˜è®¤æ¯ä¸ªæ ä½æ”¾ä¸€å¼ å¡ç‰Œ
                                this.addToLog(`æœ‰æ˜ç¡®çš„æ ä½åˆ†é…ä¿¡æ¯??????`);
                                for (let i = 0; i < Math.min(data.cards_played.length, 4); i++) {
                                    this.opponentCurrentRoundSlots[i] = [data.cards_played[i]];
                                }
                            }
                            
                            // æ›´æ–°UIæ˜¾ç¤º
                            this.updateOpponentCurrentRoundDisplay();
                        }
                        break;
                        
                    case 'opponent_disconnected':
                        this.addToLog(`âš ï¸ ${data.message}`);
                        break;
                        
                    case 'opponent_reconnected':
                        this.addToLog(`ğŸ”— ${data.message}`);
                        break;
                        
                    case 'waiting_for_opponent':
                        this.addToLog(`â³ ${data.message}`);
                        break;
                        
                    case 'special_action_request': // æ–°å¢ï¼šæ¥æ”¶åˆ°ç‰¹æ®Šæ“ä½œæŒ‡ä»¤
                        this.showSpecialActions(data.instruction || 'è¯·é€‰æ‹©æ“ä½œ');
                        break;
                }
            }
            
            // æ–°å¢ï¼šæ˜¾ç¤ºç‰¹æ®Šæ“ä½œæŒ‰é’®
            showSpecialActions(instruction) {
                const container = document.getElementById('specialActionsContainer');
                if (container) {
                    // æ›´æ–°æ ‡é¢˜
                    const titleElement = container.querySelector('.special-actions-title');
                    if (titleElement) {
                        titleElement.textContent = `âš¡ ${instruction}`;
                    }
                    
                    // æ˜¾ç¤ºå®¹å™¨
                    container.style.display = 'block';
                    this.addToLog(`æ”¶åˆ°ç‰¹æ®Šæ“ä½œæŒ‡ä»¤: ${instruction}`);
                }
            }
            
            // æ–°å¢ï¼šéšè—ç‰¹æ®Šæ“ä½œæŒ‰é’®
            hideSpecialActions() {
                const container = document.getElementById('specialActionsContainer');
                if (container) {
                    container.style.display = 'none';
                }
            }
            
            // æ–°å¢ï¼šå‘é€ç‰¹æ®Šæ“ä½œæ¶ˆæ¯
            sendSpecialAction(actionType) {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const actionMsg = {
                        type: 'special_action',
                        player_id: this.playerId,
                        action_type: actionType
                    };
                    
                    this.sendMessage(actionMsg);
                    this.addToLog(`å‘é€ç‰¹æ®Šæ“ä½œ: ${actionType}`);
                    
                    // å‘é€åéšè—æŒ‰é’®åŒºåŸŸ
                    this.hideSpecialActions();
                } else {
                    this.addToLog('æ— æ³•å‘é€ç‰¹æ®Šæ“ä½œ: WebSocket æœªè¿æ¥');
                }
            }
            
            // ä¿®æ”¹åçš„ï¼šæ›´æ–°å¯¹æ–¹å¡ç‰Œä½ç½®
            updateOpponentCard(slotIndex, cardData, action) {
                if (slotIndex < 0 || slotIndex > 3) return;
                
                if (action === 'add') {
                    // æ·»åŠ å¡ç‰Œåˆ°å¯¹æ–¹å¯¹åº”æ ä½
                    this.opponentCurrentRoundSlots[slotIndex].push(cardData);
                } else if (action === 'remove') {
                    // ä»å¯¹æ–¹å¯¹åº”æ ä½ç§»é™¤å¡ç‰Œ
                    const cardIndex = this.opponentCurrentRoundSlots[slotIndex].findIndex(
                        card => card.name === cardData.name && 
                        card.HP === cardData.HP && 
                        card.ATK === cardData.ATK
                    );
                    if (cardIndex !== -1) {
                        this.opponentCurrentRoundSlots[slotIndex].splice(cardIndex, 1);
                    }
                } else if (action === 'clear') {
                    // æ¸…ç©ºå¯¹æ–¹æ•´ä¸ªæ ä½
                    this.opponentCurrentRoundSlots[slotIndex] = [];
                }
                
                this.updateOpponentCurrentRoundDisplay();
            }
            
            sendCardPlacementUpdate(slotIndex, cardData, action) {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const updateMsg = {
                        type: 'card_placement_update',
                        player_id: this.playerId,
                        slot_index: slotIndex,
                        card: cardData,
                        action: action // 'add', 'remove', 'clear'
                    };
                    
                    this.sendMessage(updateMsg);
                }
            }
            
            joinGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'player_join',
                        player_id: this.playerId
                    };
                    console.log('Sending join message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`ä»¥ ${this.playerId} èº«ä»½åŠ å…¥æ¸¸æˆ...`);
                    document.getElementById('joinButton').disabled = true;
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•åŠ å…¥: WebSocket æœªè¿æ¥');
                }
            }

            ReGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'start_new_round',
                        player_id: this.playerId
                    };
                    console.log('Sending ReGame message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`è¯·æ±‚æ–°çš„æ¸¸æˆå›åˆ...`);
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•è¯·æ±‚æ–°å›åˆ: WebSocket æœªè¿æ¥');
                }
            }
            
            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    console.log('Message sent:', message);
                } else {
                    console.error('Cannot send message: WebSocket not open');
                    this.addToLog('é”™è¯¯: æ— æ³•å‘é€æ¶ˆæ¯ - è¿æ¥å·²å…³é—­');
                }
            }
            
            showCardDetail(card) {
                document.getElementById('detailCardName').textContent = card.name;
                document.getElementById('detailCardHP').textContent = card.HP || 0;
                document.getElementById('detailCardATK').textContent = card.ATK || 0;
                document.getElementById('detailCardProperty').textContent = card.property || "æ— ";
                document.getElementById('detailCardRace').textContent = card.race || "æ— ";
                
                // å¤„ç†è´¹ç”¨æ˜¾ç¤º
                let costText = "æ— ";
                if (card.cost && Array.isArray(card.cost)) {
                    costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                } else if (card.cost && typeof card.cost === 'object') {
                    costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                }
                document.getElementById('detailCardCost').textContent = costText;
                
                document.getElementById('cardDetailModal').style.display = 'flex';
            }
            
            renderCards() {
                const grid = document.getElementById('cardsGrid');
                grid.innerHTML = '';
                
                if (this.cards.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; width: 100%; color: #666; padding: 20px;">æš‚æ— å¡ç‰Œ</div>';
                    return;
                }
                
                // æ˜¾ç¤ºæ‰€æœ‰å¡ç‰Œï¼ŒåŒ…æ‹¬å·²ä½¿ç”¨çš„
                this.cards.forEach((card, index) => {
                    const uniqueId = `${card.name}_${index}`;
                    
                    // åˆå§‹åŒ–å¡ç‰Œä½¿ç”¨çŠ¶æ€
                    if (!this.cardUsageMap.has(uniqueId)) {
                        this.cardUsageMap.set(uniqueId, {
                            card: card,
                            used: false,
                            slotIndex: -1
                        });
                    }
                    
                    const cardElement = this.createCardElement(card, index);
                    grid.appendChild(cardElement);
                });
            }
            
            createCardElement(card, index, isSlotCard = false) {
                const uniqueId = `${card.name}_${index}`;
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.dataset.index = index;
                cardDiv.dataset.uniqueId = uniqueId;
                
                // åªæœ‰åœ¨"your cards"ä¸­ä¸”æœªè¢«ä½¿ç”¨æ—¶æ‰å¯æ‹–åŠ¨
                if (!isSlotCard) {
                    const usage = this.cardUsageMap.get(uniqueId);
                    cardDiv.draggable = !(usage && usage.used);
                    
                    // å¦‚æœå¡ç‰Œå·²è¢«ä½¿ç”¨ï¼ˆåœ¨æ ä½ä¸­ï¼‰ï¼Œæ·»åŠ usedç±»ä½¿å…¶å˜ç°
                    if (usage && usage.used) {
                        cardDiv.classList.add('used');
                    }
                } else {
                    // æ ä½ä¸­çš„å¡ç‰Œä¸å¯æ‹–åŠ¨ï¼Œä½†ä¿æŒæ­£å¸¸æ˜¾ç¤º
                    cardDiv.draggable = false;
                    // æ ä½å¡ç‰Œæ·»åŠ ç‰¹å®šç±»
                    cardDiv.classList.add('slot-card-instance');
                }
                
                // åˆ›å»ºå¡ç‰Œå†…å®¹
                const cardHeader = document.createElement('div');
                cardHeader.className = 'card-header';
                cardHeader.textContent = card.name;
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';
                
                // å¡ç‰Œç»Ÿè®¡æ•°æ®
                const statsDiv = document.createElement('div');
                statsDiv.className = 'card-stats';
                
                const hpStat = document.createElement('div');
                hpStat.className = 'stat';
                hpStat.innerHTML = `<div class="stat-value">${card.HP || 0}</div><div class="stat-label">HP</div>`;
                
                const atkStat = document.createElement('div');
                atkStat.className = 'stat';
                atkStat.innerHTML = `<div class="stat-value">${card.ATK || 0}</div><div class="stat-label">ATK</div>`;
                
                statsDiv.appendChild(hpStat);
                statsDiv.appendChild(atkStat);
                
                // å¡ç‰Œå±æ€§
                const propertiesDiv = document.createElement('div');
                propertiesDiv.className = 'card-properties';
                
                if (card.race) {
                    const raceSpan = document.createElement('span');
                    raceSpan.className = 'property race';
                    raceSpan.textContent = card.race;
                    propertiesDiv.appendChild(raceSpan);
                }
                
                if (card.property) {
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'property type';
                    typeSpan.textContent = card.property;
                    propertiesDiv.appendChild(typeSpan);
                }
                
                // å¡ç‰Œè´¹ç”¨
                const costDiv = document.createElement('div');
                costDiv.className = 'card-cost';
                
                if (card.cost) {
                    let costText = "";
                    if (Array.isArray(card.cost)) {
                        costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                    } else if (typeof card.cost === 'object') {
                        costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                    }
                    if(!costText){
                        costDiv.textContent = "è´¹ç”¨: æ— ";
                    } else {
                        costDiv.textContent = `è´¹ç”¨: ${costText}`;
                    }
                } else {
                    costDiv.textContent = "è´¹ç”¨: æ— ";
                }
                
                // ç»„è£…å¡ç‰Œ
                cardBody.appendChild(statsDiv);
                cardBody.appendChild(propertiesDiv);
                
                cardDiv.appendChild(cardHeader);
                cardDiv.appendChild(cardBody);
                cardDiv.appendChild(costDiv);
                
                // å³é”®ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…
                cardDiv.oncontextmenu = (e) => {
                    e.preventDefault();
                    this.showCardDetail(card);
                    return false;
                };
                
                return cardDiv;
            }
            
            updateCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.slot');
                slots.forEach((slot, index) => {
                    const cards = this.currentRoundSlots[index];
                    
                    // æ¸…é™¤æ—§å†…å®¹
                    slot.innerHTML = '';
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'slot-empty';
                        emptyDiv.textContent = 'æ‹–æ”¾å¡ç‰Œåˆ°è¿™é‡Œ';
                        slot.appendChild(emptyDiv);
                    } else {
                        // åˆ›å»ºå¡ç‰Œå®¹å™¨
                        const cardsContainer = document.createElement('div');
                        cardsContainer.style.width = '100%';
                        
                        cards.forEach((card, cardIndex) => {
                            const cardWrapper = document.createElement('div');
                            cardWrapper.style.position = 'relative';
                            cardWrapper.style.marginBottom = '10px';
                            
                            // åˆ›å»ºå®Œæ•´å¡ç‰Œå…ƒç´ ï¼ˆå’ŒYour Cardsä¸­çš„ä¸€æ ·ï¼‰
                            const cardElement = this.createCardElement(card, cardIndex);
                            cardElement.classList.add('slot-card');
                            cardElement.style.width = '170px';
                            cardElement.style.margin = '0 auto';
                            
                            cardWrapper.appendChild(cardElement);
                            cardsContainer.appendChild(cardWrapper);
                        });
                        
                        slot.appendChild(cardsContainer);
                    }
                    
                    // æ·»åŠ æ•´ä¸ªæ ä½çš„æ¸…é™¤æŒ‰é’®
                    const clearAllBtn = document.createElement('button');
                    clearAllBtn.className = 'clear-slot-btn';
                    clearAllBtn.innerHTML = 'Ã—';
                    clearAllBtn.title = 'æ¸…ç©ºæ•´ä¸ªæ ä½';
                    
                    clearAllBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeCardFromSlot(index);
                    });
                    
                    slot.appendChild(clearAllBtn);
                    
                    // é¼ æ ‡æ‚¬åœåœ¨æ ä½æ—¶æ˜¾ç¤ºæ¸…é™¤æŒ‰é’®
                    slot.addEventListener('mouseenter', () => {
                        if (cards.length > 0) {
                            clearAllBtn.style.display = 'block';
                        }
                    });
                    
                    slot.addEventListener('mouseleave', () => {
                        clearAllBtn.style.display = 'none';
                    });
                });
               
                document.getElementById('playButton').disabled = false;
            }
            
            updateOpponentCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.opponent-slot');
                slots.forEach((slot, index) => {
                    const cards = this.opponentCurrentRoundSlots[index];
                    
                    // æ¸…é™¤æ—§å†…å®¹
                    slot.innerHTML = '';
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'opponent-slot-empty';
                        emptyDiv.textContent = 'ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ';
                        slot.appendChild(emptyDiv);
                    } else {
                        // åˆ›å»ºå¡ç‰Œå®¹å™¨
                        const cardsContainer = document.createElement('div');
                        cardsContainer.style.width = '100%';
                        
                        cards.forEach((card, cardIndex) => {
                            const cardWrapper = document.createElement('div');
                            cardWrapper.style.position = 'relative';
                            cardWrapper.style.marginBottom = '10px';
                            
                            // åˆ›å»ºå®Œæ•´å¡ç‰Œå…ƒç´ 
                            const cardElement = this.createCardElement(card, cardIndex);
                            cardElement.classList.add('opponent-slot-card');
                            cardElement.style.width = '170px';
                            cardElement.style.margin = '0 auto';
                            cardElement.style.opacity = '0.9';
                            
                            cardWrapper.appendChild(cardElement);
                            cardsContainer.appendChild(cardWrapper);
                        });
                        
                        slot.appendChild(cardsContainer);
                    }
                });
            }
            
            addCardToSlot(slotIndex, cardData) {
                const uniqueId = cardData.uniqueId;
                
                // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²è¢«ä½¿ç”¨
                if (!this.cardUsageMap.has(uniqueId)) {
                    return false;
                }
                
                const usage = this.cardUsageMap.get(uniqueId);
                if (usage.used && usage.slotIndex !== slotIndex) {
                    // å¡ç‰Œå·²è¢«å…¶ä»–æ ä½ä½¿ç”¨ï¼Œå…ˆä»ä¸­ç§»é™¤
                    this.removeCardFromSlot(usage.slotIndex, uniqueId);
                }
                
                // å¦‚æœå·²ç»åœ¨åŒä¸€ä¸ªæ ä½ï¼Œä¸éœ€è¦é‡å¤æ·»åŠ 
                if (usage.used && usage.slotIndex === slotIndex) {
                    return true;
                }
                
                // æ·»åŠ åˆ°æŒ‡å®šæ ä½
                const cardInSlot = {
                    ...cardData.card,
                    uniqueId: uniqueId,
                    slotIndex: slotIndex
                };
                this.currentRoundSlots[slotIndex].push(cardInSlot);
                
                // æ›´æ–°å¡ç‰Œä½¿ç”¨çŠ¶æ€
                usage.used = true;
                usage.slotIndex = slotIndex;
                
                // å‘é€æ”¾ç½®æ›´æ–°ç»™å¯¹æ‰‹
                this.sendCardPlacementUpdate(slotIndex, cardData.card, 'add');
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
                return true;
            }
            
            removeCardFromSlot(slotIndex, specificUniqueId = null) {
                if (this.currentRoundSlots[slotIndex].length === 0) return;
                
                if (specificUniqueId !== null) {
                    // ç§»é™¤ç‰¹å®šå¡ç‰Œ
                    const cardIndex = this.currentRoundSlots[slotIndex].findIndex(
                        card => card.uniqueId === specificUniqueId
                    );
                    if (cardIndex !== -1) {
                        const removedCard = this.currentRoundSlots[slotIndex][cardIndex];
                        this.currentRoundSlots[slotIndex].splice(cardIndex, 1);
                        
                        // æ›´æ–°å¡ç‰Œä½¿ç”¨çŠ¶æ€
                        if (this.cardUsageMap.has(removedCard.uniqueId)) {
                            const usage = this.cardUsageMap.get(removedCard.uniqueId);
                            usage.used = false;
                            usage.slotIndex = -1;
                        }
                        
                        // å‘é€ç§»é™¤æ›´æ–°ç»™å¯¹æ‰‹
                        this.sendCardPlacementUpdate(slotIndex, removedCard, 'remove');
                    }
                } else {
                    // ç§»é™¤æ•´ä¸ªæ ä½çš„æ‰€æœ‰å¡ç‰Œ
                    const removedCards = [...this.currentRoundSlots[slotIndex]];
                    this.currentRoundSlots[slotIndex] = [];
                    
                    // æ›´æ–°æ‰€æœ‰å¡ç‰Œçš„ä½¿ç”¨çŠ¶æ€
                    removedCards.forEach(card => {
                        if (this.cardUsageMap.has(card.uniqueId)) {
                            const usage = this.cardUsageMap.get(card.uniqueId);
                            usage.used = false;
                            usage.slotIndex = -1;
                        }
                    });
                }
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }
            
            playCurrentRoundCards() {
                if (!this.connected ) {
                    this.addToLog('âŒè¿æ¥å¤±è´¥');
                    return;
                }
                
                // æ”¶é›†æ‰€æœ‰æ ä½çš„å¡ç‰Œ
                const allCards = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    const slotCards = this.currentRoundSlots[i].map(card => {
                        return {
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            cost: card.cost,
                            id:card.card_id

                        };
                    });
                    allCards.push(...slotCards);
                }
                
                if (allCards.length === 0) {
                    this.addToLog('å·²ç»“æŸï¼Œæ²¡æœ‰å‡ºç‰Œ');
                    document.getElementById('playButton').disabled = true;
                }
                
                // è®°å½•å“ªäº›å¡ç‰Œè¢«æ‰“å‡ºäº†ï¼ˆæ°¸ä¹…ç§»é™¤ï¼‰
                const playedUniqueIds = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    this.currentRoundSlots[i].forEach(card => {
                        playedUniqueIds.push(card.uniqueId);
                    });
                }
                
                const playMsg = {
                    type: 'player_action',
                    player_id: this.playerId,
                    cards: allCards.map(card => card.name),
                    slots: this.currentRoundSlots.map(slot => 
                        slot.map(card => ({
                            name: card.name,
                            HP: card.HP,
                            ATK: card.ATK,
                            property: card.property,
                            race: card.race,
                            id:card.card_id
                        }))
                    ),
                    card_details: allCards
                };
                
                console.log('Sending play message:', playMsg);
                this.sendMessage(playMsg);
                this.addToLog(`æ‰“å‡ºå¡ç‰Œ: ${allCards.map(c => c.name).join(', ')}`);
                
                // ä»å¡ç‰Œåˆ—è¡¨ä¸­æ°¸ä¹…ç§»é™¤æ‰“å‡ºçš„å¡ç‰Œ
                this.cards = this.cards.filter((card, index) => {
                    const uniqueId = `${card.name}_${index}`;
                    return !playedUniqueIds.includes(uniqueId);
                });
                
                // æ¸…é™¤å¡ç‰Œä½¿ç”¨çŠ¶æ€
                playedUniqueIds.forEach(uniqueId => {
                    this.cardUsageMap.delete(uniqueId);
                });
                
                // // é‡ç½®å½“å‰å›åˆæ ä½
                // this.lastClickedCard = null;
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }
            
            updateStatus(message, type) {
                const statusDiv = document.getElementById('connectionStatus');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
            }
            
            addToLog(message) {
                const logDiv = document.getElementById('gameLog');
                const timestamp = new Date().toLocaleTimeString();
                logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.min(1000 * this.reconnectAttempts, 10000);
                    
                    console.log(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts})`);
                    this.updateStatus(`ğŸ”„ é‡æ–°è¿æ¥ä¸­... (å°è¯• ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'info');
                    
                    setTimeout(() => {
                        this.connect();
                    }, delay);
                } else {
                    console.error('Max reconnection attempts reached');
                    this.updateStatus('âŒ è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€å’ŒIPåœ°å€', 'error');
                }
            }
        }
        
        let gameClient;
        
        // å…¨å±€æ‹–æ”¾å¤„ç†å‡½æ•°
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('highlight');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('highlight');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('highlight');
            
            try {
                const data = JSON.parse(e.dataTransfer.getData('application/json'));
                const slotIndex = parseInt(e.currentTarget.dataset.slotIndex);
                
                if (gameClient && gameClient.addCardToSlot(slotIndex, data)) {
                    // æˆåŠŸæ·»åŠ 
                }
            } catch (error) {
                console.error('Drop error:', error);
            }
        }
        
        // function handleSlotClick(slotIndex) {
        //     if (gameClient && gameClient.lastClickedCard) {
        //         gameClient.addCardToSlot(slotIndex, gameClient.lastClickedCard);
        //         gameClient.lastClickedCard = null;
        //     }
        // }
        
        function clearSlot(slotIndex, uniqueId = null, e = null) {
            if (e) e.stopPropagation();
            if (gameClient) {
                if (uniqueId) {
                    // æ¸…é™¤ç‰¹å®šå¡ç‰Œ
                    gameClient.removeCardFromSlot(slotIndex, uniqueId);
                } else {
                    // æ¸…é™¤æ•´ä¸ªæ ä½
                    gameClient.removeCardFromSlot(slotIndex);
                }
            }
        }
        
        // æ–°å¢ï¼šå‘é€ç‰¹æ®Šæ“ä½œçš„å…¨å±€å‡½æ•°
        function sendSpecialAction(actionType) {
            if (gameClient) {
                gameClient.sendSpecialAction(actionType);
            }
        }
        
        function playCurrentRoundCards() {
            if (gameClient) {
                gameClient.playCurrentRoundCards();
            }
        }
        
        function closeCardDetail() {
            document.getElementById('cardDetailModal').style.display = 'none';
        }
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('cardDetailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCardDetail();
            }
        });
        
        window.onload = function() {
            gameClient = new GameClient();
        };
        
        function joinGame() {
            if (gameClient) {
                gameClient.joinGame();
            }
        }

        function ReGame() {
            if (gameClient) {
                gameClient.ReGame();
            }
        }
        
        function updateServerIP() {
            if (gameClient) {
                gameClient.reconnectAttempts = 0;
                gameClient.connect();
            }
        }
    </script>
</body>
</html>