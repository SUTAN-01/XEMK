<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Duel Game</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .game-container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .player-section { border: 2px solid #333; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .cards-grid { display: flex; flex-wrap: wrap; gap: 15px; margin: 10px 0; }
        .card { 
            width: 180px; 
            display: flex; flex-direction: column;
            border: 2px solid #007bff; border-radius: 8px;
            cursor: grab; background: white; transition: all 0.2s;
            user-select: none; overflow: hidden;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .card:hover { transform: translateY(-5px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .card.selected { border-color: #28a745; box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3); }
        .card.used { 
            opacity: 0.5; 
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card.dragging {
            opacity: 0.7;
            transform: scale(1.05);
        }
        
        /* å¡ç‰Œå†…éƒ¨æ ·å¼ */
        .card-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        .card-body {
            padding: 10px;
            flex-grow: 1;
        }
        
        .card-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        
        .card-properties {
            margin-top: 8px;
            font-size: 14px;
        }
        
        .property {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 4px;
            margin-bottom: 4px;
            font-size: 12px;
        }
        
        .property.race {
            background: #d4edda;
            color: #155724;
        }
        
        .property.type {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .card-cost {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .cost-item {
            display: inline-block;
            margin-right: 5px;
            color: #6c757d;
        }
        
        .controls { margin: 15px 0; text-align: center; }
        button { 
            padding: 12px 24px; margin: 5px; cursor: pointer; 
            background: #28a745; color: white; border: none; border-radius: 5px;
            font-size: 16px; transition: background 0.2s;
        }
        button:hover { background: #218838; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        #gameLog { 
            height: 200px; overflow-y: auto; border: 1px solid #ccc; 
            padding: 10px; margin: 10px 0; background-color: #f8f9fa;
            border-radius: 5px; font-family: monospace;
        }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .config-section { background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 5px; margin: 10px 0; }
        
        /* å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œæ ·å¼ */
        .current-round-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }
        
        .current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slot {
            width: 100%;
            min-height: 200px;
            border: 3px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            transition: all 0.2s;
            position: relative;
            padding: 10px;
        }
        
        .slot.highlight {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .slot-card {
            width: 160px;
            transform: scale(0.9);
        }
        
        .slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        .clear-slot-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            display: none;
            z-index: 10;
        }
        
        .slot:hover .clear-slot-btn {
            display: block;
        }
        
        /* å¯¹æ–¹å½“å‰å›åˆæ ·å¼ */
        .opponent-current-round-section {
            margin-top: 30px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
            border: 2px solid #ced4da;
        }
        
        .opponent-current-round-section h3 {
            margin-top: 0;
            color: #495057;
            text-align: center;
        }
        
        .opponent-slot-container {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .opponent-slot-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }
        
        .opponent-slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
            font-size: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .opponent-slot {
            width: 100%;
            min-height: 200px;
            border: 3px solid #6c757d;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            padding: 10px;
        }
        
        .opponent-slot-card {
            width: 160px;
            transform: scale(0.9);
            opacity: 0.9;
        }
        
        .opponent-slot-empty {
            color: #adb5bd;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        /* å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— */
        .card-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .card-detail-content {
            background: white;
            border-radius: 10px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .card-detail-header {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .card-detail-body {
            padding: 20px;
        }
        
        .detail-row {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .detail-label {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }
        
        .detail-value {
            font-size: 16px;
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        
        /* æ¸¸æˆçŠ¶æ€é¢æ¿æ ·å¼ */
        .game-state-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .player-state {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .player-state h4 {
            margin-top: 0;
            color: #495057;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }
        
        .state-info {
            margin-bottom: 10px;
        }
        
        .state-label {
            font-weight: bold;
            color: #6c757d;
        }
        
        .state-value {
            color: #495057;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="text-align: center; color: #333;">ğŸƒ Card Duel Game</h1>
        
        <div class="config-section">
            <h3>âš™ï¸ è¿æ¥è®¾ç½®</h3>
            <label for="serverIP">æ¸¸æˆæœåŠ¡å™¨IPåœ°å€:</label>
            <input type="text" id="serverIP" value="10.2.3.31" style="padding: 5px; margin: 0 10px;">
            <button onclick="updateServerIP()">æ›´æ–°è¿æ¥</button>
            <p><small>æç¤º: åœ¨ROS 2ä¸»æœºä¸Šè¿è¡Œ <code>hostname -I</code> æŸ¥çœ‹IPåœ°å€</small></p>
        </div>
        
        <div id="connectionStatus" class="status info">å‡†å¤‡è¿æ¥...</div>
        
        <div class="player-section">
            <h2>ğŸƒ Your Cards</h2>
            <div id="cardsGrid" class="cards-grid">No cards yet. Join the game first.</div>
            
            <!-- å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œï¼ˆå¯æ”¾ç½®åŒºåŸŸï¼‰ -->
            <div class="current-round-section">
                <h3>å½“å‰å›åˆè¦ä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="slot-container">
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 1</div>
                        <div class="slot" data-slot-index="0" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(0)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                            <button class="clear-slot-btn" onclick="clearSlot(0, event)">Ã—</button>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 2</div>
                        <div class="slot" data-slot-index="1" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(1)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                            <button class="clear-slot-btn" onclick="clearSlot(1, event)">Ã—</button>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 3</div>
                        <div class="slot" data-slot-index="2" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(2)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                            <button class="clear-slot-btn" onclick="clearSlot(2, event)">Ã—</button>
                        </div>
                    </div>
                    <div class="slot-column">
                        <div class="slot-title">æ ä½ 4</div>
                        <div class="slot" data-slot-index="3" ondragover="handleDragOver(event)" ondrop="handleDrop(event)" ondragleave="handleDragLeave(event)" onclick="handleSlotClick(3)">
                            <div class="slot-empty">æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ</div>
                            <button class="clear-slot-btn" onclick="clearSlot(3, event)">Ã—</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ -->
            <div class="opponent-current-round-section">
                <h3>å¯¹æ–¹å½“å‰å›åˆä½¿ç”¨çš„å¡ç‰Œ</h3>
                <div class="opponent-slot-container">
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 1</div>
                        <div class="opponent-slot" data-opponent-slot-index="0">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 2</div>
                        <div class="opponent-slot" data-opponent-slot-index="1">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 3</div>
                        <div class="opponent-slot" data-opponent-slot-index="2">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                    <div class="opponent-slot-column">
                        <div class="opponent-slot-title">æ ä½ 4</div>
                        <div class="opponent-slot" data-opponent-slot-index="3">
                            <div class="opponent-slot-empty">ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="joinButton" onclick="joinGame()">åŠ å…¥æ¸¸æˆ</button>
                <button id="playButton" onclick="playCurrentRoundCards()" disabled>æ‰“å‡ºé€‰æ‹©çš„å¡ç‰Œ</button>
                <button id="endButton" onclick="ReGame()">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
        
        <div class="player-section">
            <h2>ğŸ“Š æ¸¸æˆçŠ¶æ€</h2>
            <div id="gameState">ç­‰å¾…ç©å®¶åŠ å…¥...</div>
        </div>
        
        <div class="player-section">
            <h2>ğŸ“ æ¸¸æˆæ—¥å¿—</h2>
            <div id="gameLog">æ¸¸æˆæ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        </div>
    </div>

    <!-- å¡ç‰Œè¯¦ç»†ä¿¡æ¯å¼¹çª— -->
    <div class="card-detail-modal" id="cardDetailModal">
        <div class="card-detail-content">
            <div class="card-detail-header">
                <span id="detailCardName">å¡ç‰Œåç§°</span>
                <button class="close-modal" onclick="closeCardDetail()">Ã—</button>
            </div>
            <div class="card-detail-body">
                <div class="detail-row">
                    <div class="detail-label">ç”Ÿå‘½å€¼ (HP)</div>
                    <div class="detail-value" id="detailCardHP">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">æ”»å‡»åŠ› (ATK)</div>
                    <div class="detail-value" id="detailCardATK">0</div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">å±æ€§</div>
                    <div class="detail-value" id="detailCardProperty">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">ç§æ—</div>
                    <div class="detail-value" id="detailCardRace">æ— </div>
                </div>
                <div class="detail-row">
                    <div class="detail-label">è´¹ç”¨</div>
                    <div class="detail-value" id="detailCardCost">æ— </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GameClient {
            constructor() {
                this.ws = null;
                this.playerId = null;
                this.cards = []; // å­˜å‚¨å¡ç‰Œå¯¹è±¡æ•°ç»„
                this.selectedCards = []; // é€‰ä¸­çš„å¡ç‰Œ
                this.connected = false;
                this.serverIP = '10.2.3.31';
                this.isConnected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.round = 0;
                this.currentRound = 0;
                
                // å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.currentRoundSlots = [[], [], [], []];
                // å¯¹æ–¹å½“å‰å›åˆçš„å››ä¸ªæ ä½æ•°æ®
                this.opponentCurrentRoundSlots = [[], [], [], []];
                // æœ€è¿‘ç‚¹å‡»çš„å¡ç‰Œï¼ˆç”¨äºç‚¹å‡»æ”¾ç½®ï¼‰
                this.lastClickedCard = null;
                
                // ä»URLè·å–ç©å®¶ID
                const urlParams = new URLSearchParams(window.location.search);
                this.playerId = urlParams.get('player') || 'player1';
                
                // è®¾ç½®IPè¾“å…¥æ¡†çš„é»˜è®¤å€¼
                document.getElementById('serverIP').value = this.getDefaultIP();
                
                this.connect();
                this.initDragAndDrop();
            }
            
            getDefaultIP() {
                return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
                    ? 'localhost' 
                    : '10.2.3.31';
            }
            
            initDragAndDrop() {
                // å¡ç‰Œæ‹–åŠ¨äº‹ä»¶
                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('card') && !e.target.classList.contains('used')) {
                        const cardIndex = parseInt(e.target.dataset.index);
                        const card = this.cards[cardIndex];
                        e.dataTransfer.setData('application/json', JSON.stringify({
                            card: card,
                            index: cardIndex,
                            uniqueId: `${card.name}_${cardIndex}`
                        }));
                        e.target.classList.add('dragging');
                    }
                });
                
                document.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('card')) {
                        e.target.classList.remove('dragging');
                    }
                });
            }
            
            connect() {
                if (this.ws) {
                    this.ws.close();
                }
                
                this.serverIP = document.getElementById('serverIP').value || this.getDefaultIP();
                const wsUrl = `ws://${this.serverIP}:8002`;
                
                try {
                    this.updateStatus(`ğŸ”— æ­£åœ¨è¿æ¥åˆ° ${this.serverIP}:8002`, 'info');
                    console.log('Connecting to:', wsUrl);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to game server');
                        this.isConnected = true;
                        this.connected = true;
                        this.reconnectAttempts = 0;
                        this.updateStatus('âœ… å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨', 'success');
                        this.addToLog('å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨ ' + this.serverIP);
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event);
                        this.isConnected = false;
                        this.connected = false;
                        
                        if (!event.wasClean) {
                            this.handleReconnect();
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('âŒ è¿æ¥é”™è¯¯', 'error');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            console.log('Raw message received:', event.data);
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            console.error('Error parsing message:', e);
                            this.addToLog('è§£ææœåŠ¡å™¨æ¶ˆæ¯æ—¶å‡ºé”™: ' + e.message);
                        }
                    };
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateStatus('âŒ åˆ›å»ºè¿æ¥å¤±è´¥', 'error');
                    this.handleReconnect();
                }
            }
            
            handleMessage(data) {
                console.log('Parsed message:', data);
                
                switch(data.type) {
                    case 'numbers_assigned':
                        // æœåŠ¡å™¨è¿”å›çš„æ˜¯å¡ç‰Œæ•°ç»„
                        this.cards = data.cards || [];
                        // æ–°å›åˆé‡ç½®æ ä½
                        this.currentRoundSlots = [[], [], [], []];
                        this.renderCards();
                        this.updateCurrentRoundDisplay();
                        this.updateStatus('âœ… å¡ç‰Œåˆ†é…å®Œæˆ! æ¸¸æˆå‡†å¤‡å°±ç»ª', 'success');
                        
                        // æ˜¾ç¤ºå¡ç‰Œåç§°
                        const cardNames = this.cards.map(card => card.name).join(', ');
                        this.addToLog(`ä½ è·å¾—äº† ${this.cards.length} å¼ å¡ç‰Œ: ${cardNames}`);
                        
                        if (this.round % 2 === 0) {
                            this.currentRound = this.round / 2;
                            this.addToLog(`å›åˆ ${this.currentRound}`);
                        }
                        this.round += 1;
                        break;
                        
                    case 'game_start':
                        this.addToLog('ğŸ® æ¸¸æˆå¼€å§‹! åŒæ–¹ç©å®¶å·²å°±ä½');
                        this.addToLog(`ä¸Šæ¬¡å‡ºç‰Œ: ${data.last_player}`);
                        break;
                        
                    case 'game_state':
                        this.updateGameState(data);
                        break;
                  
                    case 'move_accepted':
                        // å¤„ç†è‡ªå·±æ‰“å‡ºçš„å¡ç‰Œ
                        this.addToLog(`âœ… ${data.message}`);
                        
                        // ä»cardsä¸­ç§»é™¤å·²ä½¿ç”¨çš„å¡ç‰Œ
                        if (data.cards_played && data.cards_played.length > 0) {
                            const playedCards = data.cards_played;//name
                            this.cards = this.cards.filter(card => 
                                !playedCards.includes(card.name)
                            );
                            this.renderCards();
                            
                            // æ¸…ç©ºå½“å‰å›åˆæ ä½
                            this.currentRoundSlots = [[], [], [], []];
                            this.updateCurrentRoundDisplay();
                            
                            // å¯ç”¨playæŒ‰é’®
                            document.getElementById('playButton').disabled = true;
                        }
                        break;
                        
                    case 'opponent_move':
                        // å¤„ç†å¯¹æ–¹æ‰“å‡ºçš„å¡ç‰Œ
                        if (data.cards_played && data.cards_played.length > 0) {
                            // æ›´æ–°å¯¹æ–¹æ ä½æ˜¾ç¤º
                            const cardNames = data.cards_played.name;
                            this.opponentCurrentRoundSlots = [[], [], [], []];
                            
                            // ç®€å•åˆ†é…ï¼šå¦‚æœæœ‰4ä¸ªå¡ç‰Œï¼Œæ¯ä¸ªæ ä½ä¸€ä¸ªï¼›å¦‚æœå°‘äº4ä¸ªï¼ŒæŒ‰é¡ºåºå¡«å……
                            for (let i = 0; i < Math.min(cardNames.length, 4); i++) {
                                this.opponentCurrentRoundSlots[i] = [{
                                    name: cardNames[i],
                                    // å¯ä»¥æ·»åŠ å ä½ç¬¦æ•°æ®ï¼Œæˆ–è€…ä»æœåŠ¡å™¨è·å–å®Œæ•´å¡ç‰Œä¿¡æ¯
                                    HP: data.cards_played.HP,
                                    ATK: data.cards_played.ATK,
                                    property: data.cards_played.property,
                                    race: data.cards_played.race
                                }];
                            }
                            
                            this.updateOpponentCurrentRoundDisplay();
                            this.addToLog(`å¯¹æ–¹æ‰“å‡ºå¡ç‰Œ: ${cardNames.join(', ')}`);
                        }
                        break;
                        
                    case 'opponent_disconnected':
                        this.addToLog(`âš ï¸ ${data.message}`);
                        break;
                        
                    case 'opponent_reconnected':
                        this.addToLog(`ğŸ”— ${data.message}`);
                        break;
                        
                    case 'waiting_for_opponent':
                        this.addToLog(`â³ ${data.message}`);
                        break;
                }
            }
            
            joinGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'player_join',
                        player_id: this.playerId
                    };
                    console.log('Sending join message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`ä»¥ ${this.playerId} èº«ä»½åŠ å…¥æ¸¸æˆ...`);
                    document.getElementById('joinButton').disabled = true;
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•åŠ å…¥: WebSocket æœªè¿æ¥');
                }
            }

            ReGame() {
                if (this.connected && this.ws.readyState === WebSocket.OPEN) {
                    const joinMsg = {
                        type: 'start_new_round',
                        player_id: this.playerId
                    };
                    console.log('Sending ReGame message:', joinMsg);
                    this.sendMessage(joinMsg);
                    this.addToLog(`è¯·æ±‚æ–°çš„æ¸¸æˆå›åˆ...`);
                } else {
                    this.updateStatus('âŒ æœªè¿æ¥åˆ°æœåŠ¡å™¨', 'error');
                    this.addToLog('æ— æ³•è¯·æ±‚æ–°å›åˆ: WebSocket æœªè¿æ¥');
                }
            }
            
            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    console.log('Message sent:', message);
                } else {
                    console.error('Cannot send message: WebSocket not open');
                    this.addToLog('é”™è¯¯: æ— æ³•å‘é€æ¶ˆæ¯ - è¿æ¥å·²å…³é—­');
                }
            }
            
            toggleCard(card, index) {
                // è®°å½•æœ€åç‚¹å‡»çš„å¡ç‰Œï¼Œç”¨äºç‚¹å‡»æ”¾ç½®
                this.lastClickedCard = {
                    card: card,
                    index: index,
                    uniqueId: `${card.name}_${index}`
                };
                
                // ä¹Ÿå¯ä»¥ä¿æŒé€‰ä¸­çš„è§†è§‰åé¦ˆ
                const cardElement = document.querySelector(`.card[data-index="${index}"]`);
                if (cardElement) {
                    cardElement.classList.toggle('selected');
                    
                    // æ›´æ–°selectedCardsæ•°ç»„
                    const isSelected = this.selectedCards.some(selected => selected.uniqueId === this.lastClickedCard.uniqueId);
                    if (isSelected) {
                        this.selectedCards = this.selectedCards.filter(selected => selected.uniqueId !== this.lastClickedCard.uniqueId);
                    } else {
                        this.selectedCards.push(this.lastClickedCard);
                    }
                }
            }
            
            showCardDetail(card) {
                document.getElementById('detailCardName').textContent = card.name;
                document.getElementById('detailCardHP').textContent = card.HP || 0;
                document.getElementById('detailCardATK').textContent = card.ATK || 0;
                document.getElementById('detailCardProperty').textContent = card.property || "æ— ";
                document.getElementById('detailCardRace').textContent = card.race || "æ— ";
                
                // å¤„ç†è´¹ç”¨æ˜¾ç¤º
                let costText = "æ— ";
                if (card.cost && Array.isArray(card.cost)) {
                    costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                } else if (card.cost && typeof card.cost === 'object') {
                    costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                }
                document.getElementById('detailCardCost').textContent = costText;
                
                document.getElementById('cardDetailModal').style.display = 'flex';
            }
            
            renderCards() {
                const grid = document.getElementById('cardsGrid');
                grid.innerHTML = '';
                
                if (this.cards.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; width: 100%; color: #666; padding: 20px;">æš‚æ— å¡ç‰Œ</div>';
                    return;
                }
                
                this.cards.forEach((card, index) => {
                    const cardElement = this.createCardElement(card, index);
                    grid.appendChild(cardElement);
                });
            }
            
            createCardElement(card, index) {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.dataset.index = index;
                cardDiv.draggable = true;
                
                // æ£€æŸ¥æ˜¯å¦å·²è¢«é€‰ä¸­
                const isSelected = this.selectedCards.some(
                    selected => selected.uniqueId === `${card.name}_${index}`
                );
                
                if (isSelected) {
                    cardDiv.classList.add('selected');
                }
                
                // åˆ›å»ºå¡ç‰Œå†…å®¹
                const cardHeader = document.createElement('div');
                cardHeader.className = 'card-header';
                cardHeader.textContent = card.name;
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';
                
                // å¡ç‰Œç»Ÿè®¡æ•°æ®
                const statsDiv = document.createElement('div');
                statsDiv.className = 'card-stats';
                
                const hpStat = document.createElement('div');
                hpStat.className = 'stat';
                hpStat.innerHTML = `<div class="stat-value">${card.HP || 0}</div><div class="stat-label">HP</div>`;
                
                const atkStat = document.createElement('div');
                atkStat.className = 'stat';
                atkStat.innerHTML = `<div class="stat-value">${card.ATK || 0}</div><div class="stat-label">ATK</div>`;
                
                statsDiv.appendChild(hpStat);
                statsDiv.appendChild(atkStat);
                
                // å¡ç‰Œå±æ€§
                const propertiesDiv = document.createElement('div');
                propertiesDiv.className = 'card-properties';
                
                if (card.race) {
                    const raceSpan = document.createElement('span');
                    raceSpan.className = 'property race';
                    raceSpan.textContent = card.race;
                    propertiesDiv.appendChild(raceSpan);
                }
                
                if (card.property) {
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'property type';
                    typeSpan.textContent = card.property;
                    propertiesDiv.appendChild(typeSpan);
                }
                
                // å¡ç‰Œè´¹ç”¨
                const costDiv = document.createElement('div');
                costDiv.className = 'card-cost';
                
                if (card.cost) {
                    let costText = "";
                    if (Array.isArray(card.cost)) {
                        costText = card.cost.map(item => `${item.resource}: ${item.amount}`).join(', ');
                    } else if (typeof card.cost === 'object') {
                        costText = Object.entries(card.cost).map(([resource, amount]) => `${resource}: ${amount}`).join(', ');
                    }
                    costDiv.textContent = `è´¹ç”¨: ${costText}`;
                } else {
                    costDiv.textContent = "è´¹ç”¨: æ— ";
                }
                
                // ç»„è£…å¡ç‰Œ
                cardBody.appendChild(statsDiv);
                cardBody.appendChild(propertiesDiv);
                
                cardDiv.appendChild(cardHeader);
                cardDiv.appendChild(cardBody);
                cardDiv.appendChild(costDiv);
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                cardDiv.onclick = (e) => {
                    e.stopPropagation();
                    // å·¦é”®ç‚¹å‡»é€‰ä¸­/å–æ¶ˆé€‰ä¸­
                    if (e.button === 0) {
                        this.toggleCard(card, index);
                    }
                };
                
                // å³é”®ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…
                cardDiv.oncontextmenu = (e) => {
                    e.preventDefault();
                    this.showCardDetail(card);
                    return false;
                };
                
                // åŒå‡»æŸ¥çœ‹è¯¦æƒ…
                cardDiv.ondblclick = (e) => {
                    e.stopPropagation();
                    this.showCardDetail(card);
                };
                
                return cardDiv;
            }
            
            updateCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.slot');
                slots.forEach((slot, index) => {
                    const cards = this.currentRoundSlots[index];
                    const slotContent = slot.querySelector('.slot-empty') || 
                                       slot.querySelector('.slot-card');
                    
                    // ç§»é™¤æ—§å†…å®¹
                    if (slotContent) {
                        slotContent.remove();
                    }
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'slot-empty';
                        emptyDiv.textContent = 'æ‹–æ”¾æˆ–ç‚¹å‡»å¡ç‰Œåˆ°è¿™é‡Œ';
                        slot.appendChild(emptyDiv);
                    } else if (cards.length === 1) {
                        // åªæ˜¾ç¤ºç¬¬ä¸€å¼ å¡ç‰Œçš„ç®€åŒ–ç‰ˆæœ¬
                        const card = cards[0];
                        const cardElement = this.createSimplifiedCardElement(card);
                        cardElement.classList.add('slot-card');
                        slot.appendChild(cardElement);
                    } else {
                        // å¤šå¼ å¡ç‰Œï¼Œæ˜¾ç¤ºè®¡æ•°
                        const countDiv = document.createElement('div');
                        countDiv.className = 'slot-number-item';
                        countDiv.textContent = `${cards.length} å¼ å¡ç‰Œ`;
                        countDiv.style.cssText = `
                            background: #007bff;
                            color: white;
                            padding: 10px;
                            border-radius: 5px;
                            font-weight: bold;
                            text-align: center;
                        `;
                        slot.appendChild(countDiv);
                    }
                    
                    // æ˜¾ç¤º/éšè—æ¸…é™¤æŒ‰é’®
                    const clearBtn = slot.querySelector('.clear-slot-btn');
                    if (clearBtn) {
                        clearBtn.style.display = cards.length > 0 ? 'block' : 'none';
                    }
                });
                
                // æ›´æ–°playæŒ‰é’®çŠ¶æ€
                const hasCards = this.currentRoundSlots.some(slot => slot.length > 0);
                document.getElementById('playButton').disabled = !hasCards;
            }
            
            createSimplifiedCardElement(card) {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.style.width = '160px';
                cardDiv.style.margin = '0';
                
                const cardHeader = document.createElement('div');
                cardHeader.className = 'card-header';
                cardHeader.textContent = card.name;
                cardHeader.style.fontSize = '14px';
                cardHeader.style.padding = '8px';
                
                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';
                cardBody.style.padding = '8px';
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'card-stats';
                
                const hpStat = document.createElement('div');
                hpStat.className = 'stat';
                hpStat.innerHTML = `<div class="stat-value">${card.HP || 0}</div><div class="stat-label">HP</div>`;
                
                const atkStat = document.createElement('div');
                atkStat.className = 'stat';
                atkStat.innerHTML = `<div class="stat-value">${card.ATK || 0}</div><div class="stat-label">ATK</div>`;
                
                statsDiv.appendChild(hpStat);
                statsDiv.appendChild(atkStat);
                
                cardBody.appendChild(statsDiv);
                cardDiv.appendChild(cardHeader);
                cardDiv.appendChild(cardBody);
                
                return cardDiv;
            }
            
            updateOpponentCurrentRoundDisplay() {
                const slots = document.querySelectorAll('.opponent-slot');
                slots.forEach((slot, index) => {
                    const cards = this.opponentCurrentRoundSlots[index];
                    const slotContent = slot.querySelector('.opponent-slot-empty') || 
                                       slot.querySelector('.opponent-slot-card');
                    
                    // ç§»é™¤æ—§å†…å®¹
                    if (slotContent) {
                        slotContent.remove();
                    }
                    
                    // æ·»åŠ æ–°å†…å®¹
                    if (cards.length === 0) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'opponent-slot-empty';
                        emptyDiv.textContent = 'ç­‰å¾…å¯¹æ–¹å‡ºç‰Œ';
                        slot.appendChild(emptyDiv);
                    } else if (cards.length === 1) {
                        // åªæ˜¾ç¤ºç¬¬ä¸€å¼ å¡ç‰Œçš„ç®€åŒ–ç‰ˆæœ¬
                        const card = cards[0];
                        const cardElement = this.createSimplifiedCardElement(card);
                        cardElement.classList.add('opponent-slot-card');
                        slot.appendChild(cardElement);
                    } else {
                        // å¤šå¼ å¡ç‰Œï¼Œæ˜¾ç¤ºè®¡æ•°
                        const countDiv = document.createElement('div');
                        countDiv.className = 'opponent-slot-number-item';
                        countDiv.textContent = `${cards.length} å¼ å¡ç‰Œ`;
                        countDiv.style.cssText = `
                            background: #6c757d;
                            color: white;
                            padding: 10px;
                            border-radius: 5px;
                            font-weight: bold;
                            text-align: center;
                        `;
                        slot.appendChild(countDiv);
                    }
                });
            }
            
            addCardToSlot(slotIndex, cardData) {
                // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²è¢«ä½¿ç”¨
                const originalCard = this.cards[cardData.index];
                if (!originalCard || originalCard.name !== cardData.card.name) {
                    return false; // å¡ç‰Œå·²è¢«ä½¿ç”¨
                }
                
                // æ£€æŸ¥å¡ç‰Œæ˜¯å¦å·²åœ¨å…¶ä»–æ ä½
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    if (i !== slotIndex) {
                        const cardInSlot = this.currentRoundSlots[i].find(c => c.name === cardData.card.name);
                        if (cardInSlot) {
                            return false; // å¡ç‰Œå·²åœ¨å…¶ä»–æ ä½
                        }
                    }
                }
                
                // æ·»åŠ åˆ°æŒ‡å®šæ ä½
                this.currentRoundSlots[slotIndex].push(cardData.card);
                
                // ä»selectedCardsä¸­ç§»é™¤
                this.selectedCards = this.selectedCards.filter(
                    selected => selected.uniqueId !== cardData.uniqueId
                );
                
                this.updateCurrentRoundDisplay();
                this.renderCards(); // æ›´æ–°å¡ç‰Œæ˜¾ç¤º
                return true;
            }
            
            removeCardFromSlot(slotIndex, cardIndex = null) {
                if (this.currentRoundSlots[slotIndex].length === 0) return;
                
                if (cardIndex !== null) {
                    // ç§»é™¤ç‰¹å®šå¡ç‰Œ
                    const removedCard = this.currentRoundSlots[slotIndex][cardIndex];
                    this.currentRoundSlots[slotIndex].splice(cardIndex, 1);
                    
                    // å°†å¡ç‰Œæ”¾å›å¯ç”¨åˆ—è¡¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                    const cardExists = this.cards.some(card => card.name === removedCard.name);
                    if (!cardExists) {
                        this.cards.push(removedCard);
                    }
                } else {
                    // ç§»é™¤æ•´ä¸ªæ ä½çš„æ‰€æœ‰å¡ç‰Œ
                    const removedCards = [...this.currentRoundSlots[slotIndex]];
                    this.currentRoundSlots[slotIndex] = [];
                    
                    // å°†å¡ç‰Œæ”¾å›å¯ç”¨åˆ—è¡¨
                    removedCards.forEach(card => {
                        const cardExists = this.cards.some(c => c.name === card.name);
                        if (!cardExists) {
                            this.cards.push(card);
                        }
                    });
                }
                
                this.updateCurrentRoundDisplay();
                this.renderCards();
            }
            
            playCurrentRoundCards() {
                if (!this.connected || this.currentRoundSlots.every(slot => slot.length === 0)) {
                    return;
                }
                
                // æ”¶é›†æ‰€æœ‰æ ä½çš„å¡ç‰Œåç§°
                const allCards = [];
                for (let i = 0; i < this.currentRoundSlots.length; i++) {
                    const slotCards = this.currentRoundSlots[i].map(card => card.name);
                    allCards.push(...slotCards);
                }
                
                if (allCards.length === 0) {
                    this.updateStatus('âŒ è¯·é€‰æ‹©è¦å‡ºçš„å¡ç‰Œ', 'error');
                    return;
                }
                
                const playMsg = {
                    type: 'player_action',
                    player_id: this.playerId,
                    cards: allCards, // å‘é€å¡ç‰Œåç§°æ•°ç»„
                    slots: this.currentRoundSlots.map(slot => 
                        slot.map(card => card.name)
                    )
                };
                
                console.log('Sending play message:', playMsg);
                this.sendMessage(playMsg);
                this.addToLog(`æ‰“å‡ºå¡ç‰Œ: ${allCards.join(', ')}`);
                
                // ç¦ç”¨playæŒ‰é’®ï¼Œç­‰å¾…æœåŠ¡å™¨å“åº”
                document.getElementById('playButton').disabled = true;
            }
            
            updateGameState(data) {
                const stateDiv = document.getElementById('gameState');
                
                let html = `
                    <div class="game-state-panel">
                        <div class="player-state">
                            <h4>ç©å®¶ 1</h4>
                            <div class="state-info">
                                <span class="state-label">å‰©ä½™å¡ç‰Œ:</span>
                                <span class="state-value">${data.player1?.cards_remaining || 0}</span>
                            </div>
                `;
                
                // æ˜¾ç¤ºç©å®¶1çš„å¡ç‰Œä¿¡æ¯
                if (data.player1?.cards && data.player1.cards.length > 0) {
                    html += `<div class="state-info">
                                <span class="state-label">å¡ç‰Œ:</span>
                                <span class="state-value">${data.player1.cards.map(c => c.name).join(', ')}</span>
                            </div>`;
                }
                
                html += `
                        </div>
                        <div class="player-state">
                            <h4>ç©å®¶ 2</h4>
                            <div class="state-info">
                                <span class="state-label">å‰©ä½™å¡ç‰Œ:</span>
                                <span class="state-value">${data.player2?.cards_remaining || 0}</span>
                            </div>
                `;
                
                // æ˜¾ç¤ºç©å®¶2çš„å¡ç‰Œä¿¡æ¯
                if (data.player2?.cards && data.player2.cards.length > 0) {
                    html += `<div class="state-info">
                                <span class="state-label">å¡ç‰Œ:</span>
                                <span class="state-value">${data.player2.cards.map(c => c.name).join(', ')}</span>
                            </div>`;
                }
                
                html += `
                        </div>
                    </div>
                `;
                
                stateDiv.innerHTML = html;
            }
            
            updateStatus(message, type) {
                const statusDiv = document.getElementById('connectionStatus');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
            }
            
            addToLog(message) {
                const logDiv = document.getElementById('gameLog');
                const timestamp = new Date().toLocaleTimeString();
                logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.min(1000 * this.reconnectAttempts, 10000);
                    
                    console.log(`Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts})`);
                    this.updateStatus(`ğŸ”„ é‡æ–°è¿æ¥ä¸­... (å°è¯• ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'info');
                    
                    setTimeout(() => {
                        this.connect();
                    }, delay);
                } else {
                    console.error('Max reconnection attempts reached');
                    this.updateStatus('âŒ è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€å’ŒIPåœ°å€', 'error');
                }
            }
        }
        
        let gameClient;
        
        // å…¨å±€æ‹–æ”¾å¤„ç†å‡½æ•°
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('highlight');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('highlight');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('highlight');
            
            try {
                const data = JSON.parse(e.dataTransfer.getData('application/json'));
                const slotIndex = parseInt(e.currentTarget.dataset.slotIndex);
                
                if (gameClient && gameClient.addCardToSlot(slotIndex, data)) {
                    // æˆåŠŸæ·»åŠ 
                }
            } catch (error) {
                console.error('Drop error:', error);
            }
        }
        
        function handleSlotClick(slotIndex) {
            if (gameClient && gameClient.lastClickedCard) {
                gameClient.addCardToSlot(slotIndex, gameClient.lastClickedCard);
                gameClient.lastClickedCard = null;
            }
        }
        
        function clearSlot(slotIndex, e) {
            if (e) e.stopPropagation();
            if (gameClient) {
                gameClient.removeCardFromSlot(slotIndex);
            }
        }
        
        function playCurrentRoundCards() {
            if (gameClient) {
                gameClient.playCurrentRoundCards();
            }
        }
        
        function closeCardDetail() {
            document.getElementById('cardDetailModal').style.display = 'none';
        }
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('cardDetailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCardDetail();
            }
        });
        
        window.onload = function() {
            gameClient = new GameClient();
        };
        
        function joinGame() {
            if (gameClient) {
                gameClient.joinGame();
            }
        }

        function ReGame() {
            if (gameClient) {
                gameClient.ReGame();
            }
        }
        
        function updateServerIP() {
            if (gameClient) {
                gameClient.reconnectAttempts = 0;
                gameClient.connect();
            }
        }
    </script>
</body>
</html>